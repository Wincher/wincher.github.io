{"title":"soul_gateway_src_code_learning_09","slug":"soul-gateway-src-code-learning-09","date":"2021-01-23T15:44:35.000Z","updated":"2021-01-24T17:24:24.077Z","comments":true,"excerpt":"","content":"<h3 id=\"SOUL-Admin-amp-网关-nacos-数据同步\"><a href=\"#SOUL-Admin-amp-网关-nacos-数据同步\" class=\"headerlink\" title=\"SOUL Admin &amp; 网关 nacos 数据同步\"></a>SOUL Admin &amp; 网关 nacos 数据同步</h3><p>首先准备好nacos server, 这里不详细叙述</p>\n<pre><code class=\"bash\">sh startup.sh -m standalone\n.......省略\nnacos is starting with standalone\nnacos is starting，you can check the /Users/wincher/Documents/learning/service/nacos/logs/start.out\n</code></pre>\n<p><a href=\"http://127.0.0.1:8848/nacos/index.html\" target=\"_blank\" rel=\"external\">http://127.0.0.1:8848/nacos/index.html</a>, 默认账号:密码都是nacos</p>\n<p><img src=\"/2021/01/23/soul-gateway-src-code-learning-09/00nacos_config.png\" alt=\"img\"></p>\n<p>可以看到启动了, 配置项目前也都是空的</p>\n<p>记下来配置soul</p>\n<p>类似之前的数据同步, admin和bootstrap项目的配置文件分别打开nacos的注释</p>\n<pre><code class=\"yaml\">soul:\n    sync:\n        nacos:\n      url: localhost:8848\n      namespace: 1c10d748-af86-43b9-8265-75f487d20c6c\n</code></pre>\n<p>soul-admin/pom.xml 已经添加了nacos-client</p>\n<pre><code class=\"xml\">&lt;dependency&gt;\n  &lt;groupId&gt;com.alibaba.nacos&lt;/groupId&gt;\n  &lt;artifactId&gt;nacos-client&lt;/artifactId&gt;\n  &lt;version&gt;${nacos-client.version}&lt;/version&gt;\n&lt;/dependency&gt;\n</code></pre>\n<p>soul-bootstrap/pom.xml 打开nacos的注释</p>\n<pre><code class=\"xml\">&lt;dependency&gt;\n    &lt;groupId&gt;com.alibaba.cloud&lt;/groupId&gt;\n    &lt;artifactId&gt;spring-cloud-starter-alibaba-nacos-discovery&lt;/artifactId&gt;\n    &lt;version&gt;2.1.0.RELEASE&lt;/version&gt;\n&lt;/dependency&gt;\n</code></pre>\n<p>根据log查看HttpSyncDataService逻辑, 同样实现了SyncDataService接口</p>\n<pre><code class=\"java\">public NacosSyncDataService(final ConfigService configService, final PluginDataSubscriber     pluginDataSubscriber,\n                                final List&lt;MetaDataSubscriber&gt; metaDataSubscribers, final List&lt;AuthDataSubscriber&gt; authDataSubscribers) {\n\n        super(configService, pluginDataSubscriber, metaDataSubscribers, authDataSubscribers);\n  //构造方法执行后就开始工作了\n        start();\n    }\n\n\n    public void start() {\n      //顾名思义观察不同类型的数据变化\n      //NacosSyncDataService 继承自 NacosCacheHandler.java, , updatePluginMap\n        watcherData(PLUGIN_DATA_ID, this::updatePluginMap);\n        watcherData(SELECTOR_DATA_ID, this::updateSelectorMap);\n        watcherData(RULE_DATA_ID, this::updateRuleMap);\n        watcherData(META_DATA_ID, this::updateMetaDataMap);\n        watcherData(AUTH_DATA_ID, this::updateAuthMap);\n    }\n\n//举一个 PLUGIN 的例子看看, 其他的也类似, oc是传进来的onchange时间\n//OnChange是定义在 NacosCacheHandler的内部函数式接口, 所以可以接收一个方法作为参数, 如上面的 this::updatePluginMap\n protected void watcherData(final String dataId, final OnChange oc) {\n        Listener listener = new Listener() {\n            @Override\n            public void receiveConfigInfo(final String configInfo) {\n                oc.change(configInfo);\n            }\n\n            @Override\n            public Executor getExecutor() {\n                return null;\n            }\n        };\n        oc.change(getConfigAndSignListener(dataId, listener));\n        LISTENERS.getOrDefault(dataId, new ArrayList&lt;&gt;()).add(listener);\n    }\n\n\nprotected void updatePluginMap(final String configInfo) {\n        try {\n            List&lt;PluginData&gt; pluginDataList = new ArrayList&lt;&gt;(GsonUtils.getInstance().toObjectMap(configInfo, PluginData.class).values());\n          // 同步更新的配置到本地, 之后会分析pluginDataSubscriber运行的机制, 以及配置是如何缓存在本地的\n            pluginDataList.forEach(pluginData -&gt; Optional.ofNullable(pluginDataSubscriber).ifPresent(subscriber -&gt; {\n                subscriber.unSubscribe(pluginData);\n                subscriber.onSubscribe(pluginData);\n            }));\n        } catch (JsonParseException e) {\n            log.error(&quot;sync plugin data have error:&quot;, e);\n        }\n    }\n</code></pre>\n<p>admin中实现了一组DataChangedListener, 其中NacosDataChangedListener就是帮助admin同步配置到nacos的</p>\n<pre><code class=\"java\">@Override\npublic void onPluginChanged(final List&lt;PluginData&gt; changed, final DataEventTypeEnum eventType) {\n    updatePluginMap(getConfig(PLUGIN_DATA_ID));\n    switch (eventType) {\n        case DELETE:\n            changed.forEach(plugin -&gt; PLUGIN_MAP.remove(plugin.getName()));\n            break;\n        case REFRESH:\n        case MYSELF:\n            Set&lt;String&gt; set = new HashSet&lt;&gt;(PLUGIN_MAP.keySet());\n            changed.forEach(plugin -&gt; {\n                set.remove(plugin.getName());\n                PLUGIN_MAP.put(plugin.getName(), plugin);\n            });\n            PLUGIN_MAP.keySet().removeAll(set);\n            break;\n        default:\n            changed.forEach(plugin -&gt; PLUGIN_MAP.put(plugin.getName(), plugin));\n            break;\n    }\n    publishConfig(PLUGIN_DATA_ID, PLUGIN_MAP);\n}\n</code></pre>\n<p>TODO: nacos start failed</p>\n","categories":[],"tags":[{"name":"SOUL","path":"api/tags/SOUL.json"}]}