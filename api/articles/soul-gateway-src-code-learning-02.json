{"title":"soul_gateway_src_code_learning_02","slug":"soul-gateway-src-code-learning-02","date":"2021-01-15T16:15:01.000Z","updated":"2021-01-15T17:35:57.877Z","comments":true,"excerpt":"","content":"<h3 id=\"SOUL-divide-plugin-auto-register\"><a href=\"#SOUL-divide-plugin-auto-register\" class=\"headerlink\" title=\"SOUL divide plugin auto register\"></a>SOUL divide plugin auto register</h3><p>上篇我们使用divide插件配置selector和rule成功将访问网关的请求转发到了baidu.com</p>\n<p>今天对divide plugin进一步的使用</p>\n<p>我们启动SOUL项目准备好的示例 soul-examples/soul-examples-http/src/main/java/org/dromara/soul/examples/http/SoulTestHttpApplication.java</p>\n<p>稍微留意一下log, 字面意思就是将接口注册到了网关上</p>\n<pre><code class=\"bash\">o.d.s.client.common.utils.RegisterUtils  : http client register success: {&quot;appName&quot;:&quot;http&quot;,&quot;context&quot;:&quot;/http&quot;,&quot;path&quot;:&quot;/http/test/**&quot;,&quot;pathDesc&quot;:&quot;&quot;,&quot;rpcType&quot;:&quot;http&quot;,&quot;host&quot;:&quot;127.0.0.1&quot;,&quot;port&quot;:8188,&quot;ruleName&quot;:&quot;/http/test/**&quot;,&quot;enabled&quot;:true,&quot;registerMetaData&quot;:false} \n2021-01-16 00:22:49.555  INFO 7520 --- [pool-1-thread-1] o.d.s.client.common.utils.RegisterUtils  : http client register success: {&quot;appName&quot;:&quot;http&quot;,&quot;context&quot;:&quot;/http&quot;,&quot;path&quot;:&quot;/http/order/save&quot;,&quot;pathDesc&quot;:&quot;Save order&quot;,&quot;rpcType&quot;:&quot;http&quot;,&quot;host&quot;:&quot;127.0.0.1&quot;,&quot;port&quot;:8188,&quot;ruleName&quot;:&quot;/http/order/save&quot;,&quot;enabled&quot;:true,&quot;registerMetaData&quot;:false} \n2021-01-16 00:22:49.569  INFO 7520 --- [pool-1-thread-1] o.d.s.client.common.utils.RegisterUtils  : http client register success: {&quot;appName&quot;:&quot;http&quot;,&quot;context&quot;:&quot;/http&quot;,&quot;path&quot;:&quot;/http/order/path/**&quot;,&quot;pathDesc&quot;:&quot;&quot;,&quot;rpcType&quot;:&quot;http&quot;,&quot;host&quot;:&quot;127.0.0.1&quot;,&quot;port&quot;:8188,&quot;ruleName&quot;:&quot;/http/order/path/**&quot;,&quot;enabled&quot;:true,&quot;registerMetaData&quot;:false} \n2021-01-16 00:22:49.585  INFO 7520 --- [pool-1-thread-1] o.d.s.client.common.utils.RegisterUtils  : http client register success: {&quot;appName&quot;:&quot;http&quot;,&quot;context&quot;:&quot;/http&quot;,&quot;path&quot;:&quot;/http/order/path/**/name&quot;,&quot;pathDesc&quot;:&quot;&quot;,&quot;rpcType&quot;:&quot;http&quot;,&quot;host&quot;:&quot;127.0.0.1&quot;,&quot;port&quot;:8188,&quot;ruleName&quot;:&quot;/http/order/path/**/name&quot;,&quot;enabled&quot;:true,&quot;registerMetaData&quot;:false} \n2021-01-16 00:22:49.601  INFO 7520 --- [pool-1-thread-1] o.d.s.client.common.utils.RegisterUtils  : http client register success: {&quot;appName&quot;:&quot;http&quot;,&quot;context&quot;:&quot;/http&quot;,&quot;path&quot;:&quot;/http/order/findById&quot;,&quot;pathDesc&quot;:&quot;Find by id&quot;,&quot;rpcType&quot;:&quot;http&quot;,&quot;host&quot;:&quot;127.0.0.1&quot;,&quot;port&quot;:8188,&quot;ruleName&quot;:&quot;/http/order/findById&quot;,&quot;enabled&quot;:true,&quot;registerMetaData&quot;:false}\n</code></pre>\n<p>启动后打开 <a href=\"http://127.0.0.1:9095/#/plug/divide\" target=\"_blank\" rel=\"external\">http://127.0.0.1:9095/#/plug/divide</a> admin divide plugin页面</p>\n<p><img src=\"/2021/01/16/soul-gateway-src-code-learning-02/00soul_auto_register_divide.png\" alt=\"pic\"></p>\n<p>我们发现在我们刚刚启动的示例项目中定义的接口都已经注册到了divide plugin上</p>\n<pre><code class=\"bash\"># 访问example项目获得结果\n$curl http://localhost:8188/test/findByUserId\\?userId\\=132\n{&quot;userId&quot;:&quot;132&quot;,&quot;userName&quot;:&quot;hello world&quot;}%\n由于被gateway divide plugin 配置了代理, 访问gateway http path也代理到了刚启动的example下\n$curl http://localhost:9195/http/test/findByUserId\\?userId\\=132\n{&quot;userId&quot;:&quot;132&quot;,&quot;userName&quot;:&quot;hello world&quot;}%\n</code></pre>\n<p>自动注册还是很方便控制接口访问的,今天就看看是如何实现的</p>\n<pre><code class=\"xml\">&lt;dependency&gt;\n  &lt;groupId&gt;org.dromara&lt;/groupId&gt;\n  &lt;artifactId&gt;soul-spring-boot-starter-client-springmvc&lt;/artifactId&gt;\n  &lt;version&gt;${soul.version}&lt;/version&gt;\n&lt;/dependency&gt;\n</code></pre>\n<p> 该项目引入了 soul-spring-boot-starter-client-springmvc</p>\n<pre><code class=\"xml\">&lt;dependency&gt;\n    &lt;groupId&gt;org.dromara&lt;/groupId&gt;\n    &lt;artifactId&gt;soul-client-springmvc&lt;/artifactId&gt;\n    &lt;version&gt;${project.version}&lt;/version&gt;\n&lt;/dependency&gt;\n</code></pre>\n<p>soul-examples-http 项目中application.yml</p>\n<pre><code class=\"yaml\">soul:\n  http:\n    adminUrl: http://localhost:9095\n    port: 8188\n    contextPath: /http\n    appName: http\n    full: false\n</code></pre>\n<p>配置信息用来注册到网关, 配置定义在 soul-client/soul-client-http/soul-client-springmvc/src/main/java/org/dromara/soul/client/springmvc/config/SoulSpringMvcConfig.java 中</p>\n<p>请求的发起来自 soul-client/soul-client-http/soul-client-springmvc/src/main/java/org/dromara/soul/client/springmvc/init/SpringMvcClientBeanPostProcessor.java</p>\n<pre><code class=\"java\">@Override\n    public Object postProcessAfterInitialization(@NonNull final Object bean, @NonNull final String beanName) throws BeansException {\n      // 如果配置了full, 则整个服务的所有接口都被代理, 不需要单独配置\n        if (soulSpringMvcConfig.isFull()) {\n            return bean;\n        }\n        Controller controller = AnnotationUtils.findAnnotation(bean.getClass(), Controller.class);\n        RestController restController = AnnotationUtils.findAnnotation(bean.getClass(), RestController.class);\n        RequestMapping requestMapping = AnnotationUtils.findAnnotation(bean.getClass(), RequestMapping.class);\n        if (controller != null || restController != null || requestMapping != null) {\n            SoulSpringMvcClient clazzAnnotation = AnnotationUtils.findAnnotation(bean.getClass(), SoulSpringMvcClient.class);\n            String prePath = &quot;&quot;;\n            if (Objects.nonNull(clazzAnnotation)) {\n                if (clazzAnnotation.path().indexOf(&quot;*&quot;) &gt; 1) {\n                    String finalPrePath = prePath;\n                    executorService.execute(() -&gt; RegisterUtils.doRegister(buildJsonParams(clazzAnnotation, finalPrePath), url,\n                            RpcTypeEnum.HTTP));\n                    return bean;\n                }\n                prePath = clazzAnnotation.path();\n            }\n            final Method[] methods = ReflectionUtils.getUniqueDeclaredMethods(bean.getClass());\n            for (Method method : methods) {\n                SoulSpringMvcClient soulSpringMvcClient = AnnotationUtils.findAnnotation(method, SoulSpringMvcClient.class);\n                if (Objects.nonNull(soulSpringMvcClient)) {\n                    String finalPrePath = prePath;\n                    executorService.execute(() -&gt; RegisterUtils.doRegister(buildJsonParams(soulSpringMvcClient, finalPrePath), url,\n                            RpcTypeEnum.HTTP));\n                }\n            }\n        }\n        return bean;\n    }\n</code></pre>\n<p>这段逻辑判断当我们处理一个接口的时候 ,如果配置了@SoulSpringMvcClient 注解, 那么就会 调用 RegisterUtils.doRegister 将接口信息注册到admin</p>\n<pre><code class=\"java\">public static void doRegister(final String json, final String url, final RpcTypeEnum rpcTypeEnum) {\n        try {\n            String result = OkHttpTools.getInstance().post(url, json);\n            if (AdminConstants.SUCCESS.equals(result)) {\n                log.info(&quot;{} client register success: {} &quot;, rpcTypeEnum.getName(), json);\n            } else {\n                log.error(&quot;{} client register error: {} &quot;, rpcTypeEnum.getName(), json);\n            }\n        } catch (IOException e) {\n            log.error(&quot;cannot register soul admin param, url: {}, request body: {}&quot;, url, json, e);\n        }\n    }\n</code></pre>\n<p>我们看到这个log是否很熟悉呢,和最开始soul-examples-http 启动 时的log对应上了</p>\n<p>至此我们了解了SOUL admin的一个优势就是低侵入自动注册接口到gateway</p>\n","categories":[],"tags":[{"name":"SOUL","path":"api/tags/SOUL.json"}]}