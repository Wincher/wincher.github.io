{"title":"soul_gateway_src_code_learning_10","slug":"soul-gateway-src-code-learning-10","date":"2021-01-25T16:31:42.000Z","updated":"2021-01-25T18:14:59.204Z","comments":true,"excerpt":"","content":"<p>SOUL admin/bootstrap cluster</p>\n<p>模拟soul 网关集群部署, 启动2个admin, 2个bootstrap</p>\n<p><img src=\"/2021/01/26/soul-gateway-src-code-learning-10/00parallel_run.jpg\" alt=\"img\"></p>\n<p>如上开启配置可以启动多个实例,也可以打包后通过java -jar启动</p>\n<p>在<code>soul-bootstrap</code>的<code>application.yml</code>配置刚才启动的<code>soul-admin</code>的 url</p>\n<pre><code class=\"yaml\">soul:\n    sync:\n        websocket :\n             urls: ws://localhost:9095/websocket,ws://localhost:9096/websocket\n</code></pre>\n<p>启动后分别打开 <a href=\"http://localhost:9095/#/plug/divide\" target=\"_blank\" rel=\"external\">http://localhost:9095/#/plug/divide</a>, <a href=\"http://localhost:9096/#/plug/divide\" target=\"_blank\" rel=\"external\">http://localhost:9096/#/plug/divide</a>,可以看到目前都没有数据</p>\n<p><img src=\"/2021/01/26/soul-gateway-src-code-learning-10/01no_data_admins.png\" alt=\"img\"></p>\n<p>启动一个soul-examples-http, 具体可参考前面的文章</p>\n<pre><code class=\"bash\">$curl 127.0.0.1:9195/http/order/findById\\?id=1\n{&quot;id&quot;:&quot;1&quot;,&quot;name&quot;:&quot;hello world findById&quot;}%\n$curl 127.0.0.1:9196/http/order/findById\\?id=1\n{&quot;id&quot;:&quot;1&quot;,&quot;name&quot;:&quot;hello world findById&quot;}%\n</code></pre>\n<p>这时候, 我们看到9195, 9196都可以访问代理到,实际上我们只是因为刚启动的配置注册到了admin:9196, 而后被同步到了配置了两个admin的websocket同步的9195和9196 bootstrap, 那么我好奇的是如果这个时候在启动一个example, 修改接口路径, 同步到9096,那么我们bootstrap得到的是合集还是会被覆盖呢, 接下来操作</p>\n<p>修改 soul-examples/soul-examples-http/src/main/resources/application.yml</p>\n<pre><code class=\"yaml\">server:\n  port: 8189\n  address: 0.0.0.0\nsoul:\n  http:\n    adminUrl: http://localhost:9096\n</code></pre>\n<p>soul-examples/soul-examples-http/src/main/java/org/dromara/soul/examples/http/controller/HttpTestController.java</p>\n<p>将路径改为</p>\n<pre><code class=\"java\">@GetMapping(&quot;/findById&quot;)\n@SoulSpringMvcClient(path = &quot;/9016FindById&quot;, desc = &quot;Find by id&quot;)\npublic OrderDTO findById(@RequestParam(&quot;id&quot;) final String id) {}\n</code></pre>\n<p>启动后做下</p>\n<p><img src=\"/2021/01/26/soul-gateway-src-code-learning-10/02diff_admin_selector.jpg\" alt=\"img\"></p>\n<p>可以看到 8188 和 8189 examples-http分别注册到了 9095和9096admin, 接下来测试下</p>\n<pre><code class=\"bash\">$url 127.0.0.1:9196/http/order/findById\\?id=1\n{&quot;id&quot;:&quot;1&quot;,&quot;name&quot;:&quot;hello world findById&quot;}%\n$curl 127.0.0.1:9195/http/order/findById\\?id=1\n{&quot;id&quot;:&quot;1&quot;,&quot;name&quot;:&quot;hello world findById&quot;}%\n$curl 127.0.0.1:9195/http/order/9016FindById\\?id=1\n{&quot;code&quot;:-102,&quot;message&quot;:&quot;Rule not found!&quot;,&quot;data&quot;:null}%\n$curl 127.0.0.1:9196/http/order/9016FindById\\?id=1\n{&quot;code&quot;:-102,&quot;message&quot;:&quot;Rule not found!&quot;,&quot;data&quot;:null}%\n</code></pre>\n<p>可以看到, 我们新启动的8189 examples-http并没有对任意一个bootstrap生效, 可以猜测只有第一个配置的url生效了</p>\n<p>而实际上我们看到 soul-sync-data-center/soul-sync-data-websocket/src/main/java/org/dromara/soul/plugin/sync/data/websocket/WebsocketSyncDataService.java</p>\n<pre><code class=\"java\">for (String url : urls) {\n            try {\n                clients.add(new SoulWebsocketClient(new URI(url), Objects.requireNonNull(pluginDataSubscriber), metaDataSubscribers, authDataSubscribers));\n            } catch (URISyntaxException e) {\n                log.error(&quot;websocket url({}) is error&quot;, url, e);\n            }\n        }\n        try {\n            for (WebSocketClient client : clients) {\n                boolean success = client.connectBlocking(3000, TimeUnit.MILLISECONDS);\n                if (success) {\n                    log.info(&quot;websocket connection is successful.....&quot;);\n                } else {\n                    log.error(&quot;websocket connection is error.....&quot;);\n                }\n                executor.scheduleAtFixedRate(() -&gt; {\n                    try {\n                        if (client.isClosed()) {\n                            boolean reconnectSuccess = client.reconnectBlocking();\n                            if (reconnectSuccess) {\n                                log.info(&quot;websocket reconnect is successful.....&quot;);\n                            } else {\n                                log.error(&quot;websocket reconnection is error.....&quot;);\n                            }\n                        }\n                    } catch (InterruptedException e) {\n                        log.error(&quot;websocket connect is error :{}&quot;, e.getMessage());\n                    }\n                }, 10, 30, TimeUnit.SECONDS);\n            }\n</code></pre>\n<p>明显所有的client都会同步数据,  这里留下一个TODO:看看为什么会产生这种现象</p>\n","categories":[],"tags":[{"name":"SOUL","path":"api/tags/SOUL.json"}]}