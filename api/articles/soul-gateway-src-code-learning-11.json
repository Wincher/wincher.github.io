{"title":"soul_gateway_src_code_learning_11","slug":"soul-gateway-src-code-learning-11","date":"2021-01-26T07:35:36.000Z","updated":"2021-01-27T07:27:03.708Z","comments":true,"excerpt":"","content":"<h3 id=\"一个请求是如何被SOUL处理的\"><a href=\"#一个请求是如何被SOUL处理的\" class=\"headerlink\" title=\"一个请求是如何被SOUL处理的\"></a>一个请求是如何被SOUL处理的</h3><p>至此, soul的基本使用方式已经清楚了, 接下来我们带着标题的疑问来看 一个请求是如何被SOUL处理的</p>\n<p>基于以前的结果,我们已知 会被 SoulWebHandler处理, SoulWebHandler实现了WebHandler, 我们来看下WebHandler的作用,</p>\n<p><img src=\"/2021/01/26/soul-gateway-src-code-learning-11/00webhandler.png\" alt=\"img\"></p>\n<p>注释写的很清楚, WebHandler用来处理request的, 我们知道  handler()方法处理的ServerWebExchange 是WebFlux 中对request, response的封装,那么我们定义的SoulWebHandler是如何注入到上下文中, 被Spring Flux调用的呢</p>\n<p>那WebFlux是什么呢, 看看官方的说明</p>\n<blockquote>\n<p>Spring WebFlux is a non-blocking web framework built from the ground up to take advantage of multi-core, next-generation processors and handle massive numbers of concurrent connections.</p>\n</blockquote>\n<p><strong>Spring WebFlux 是一个异步非阻塞式的 Web 框架，它能够充分利用多核 CPU 的硬件资源去处理大量的并发请求</strong></p>\n<p>显然这对比Spring MVC 所构建在servlet api上的阻塞IO模型性能要高</p>\n<p>soul-plugin/soul-plugin-api/pom.xml</p>\n\n    <pre><code class=\"lang-xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">dependency</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">groupId</span>&gt;</span>org.springframework<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">groupId</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">artifactId</span>&gt;</span>spring-webflux<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">artifactId</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">dependency</span>&gt;</span>\n</code></pre>\n<p>我们封装的核心接口也都是使用ServerWebExchange来作为request, response的载体</p>\n<p>soul-web/src/main/java/org/dromara/soul/web/configuration/SoulConfiguration.java</p>\n\n    <pre><code class=\"lang-java\"> @Bean(<span class=\"hljs-string\">\"webHandler\"</span>)\n    <span class=\"hljs-keyword\">public</span> SoulWebHandler soulWebHandler(<span class=\"hljs-keyword\">final</span> ObjectProvider&lt;<span class=\"hljs-keyword\">List</span>&lt;SoulPlugin&gt;&gt; plugins) {\n        <span class=\"hljs-keyword\">List</span>&lt;SoulPlugin&gt; pluginList = plugins.getIfAvailable(Collections::emptyList);\n      <span class=\"hljs-comment\">//初始化也利用ObjectProvider 讲所有加载进来的插件注入到SoulWebHandler中</span>\n        <span class=\"hljs-keyword\">final</span> <span class=\"hljs-keyword\">List</span>&lt;SoulPlugin&gt; soulPlugins = pluginList.stream()\n                .sorted(Comparator.comparingInt(SoulPlugin::getOrder)).collect(Collectors.toList());\n        soulPlugins.<span class=\"hljs-keyword\">forEach</span>(soulPlugin -&gt; log.info(<span class=\"hljs-string\">\"load plugin:[{}] [{}]\"</span>, soulPlugin.named(), soulPlugin.getClass().getName()));\n        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">new</span> SoulWebHandler(soulPlugins);\n    }\n</code></pre>\n<p>系统启动 webHandler会被加载进内存, 那当一个请求调用进来是哪里调用的handle方法呢, 简单的在所有调用SoulWebHandler.handler()的地方打上断点, 发现是org/springframework/web/server/handler/DefaultWebFilterChain.java的</p>\n\n    <pre><code class=\"lang-java\"><span class=\"hljs-meta\">@Override</span>\n    <span class=\"hljs-keyword\">public</span> Mono&lt;<span class=\"hljs-built_in\">Void</span>&gt; filter(ServerWebExchange exchange) {\n        <span class=\"hljs-keyword\">return</span> Mono.defer(() -&gt;\n                <span class=\"hljs-keyword\">this</span>.currentFilter != <span class=\"hljs-literal\">null</span> &amp;&amp; <span class=\"hljs-keyword\">this</span>.chain != <span class=\"hljs-literal\">null</span> ?\n                        invokeFilter(<span class=\"hljs-keyword\">this</span>.currentFilter, <span class=\"hljs-keyword\">this</span>.chain, exchange) :\n                        <span class=\"hljs-keyword\">this</span>.handler.handle(exchange));\n    }\n</code></pre>\n<p>调用了, 这里的handler正是SoulWebHandler, 追其根本,通过 org/springframework/web/server/adapter/WebHttpHandlerBuilder.java 中</p>\n\n    <pre><code class=\"lang-java\">WebHttpHandlerBuilder builder = new WebHttpHandlerBuilder(\n<span class=\"hljs-name\">//</span>这里获取到的就是我们前面创建的Bean SoulWebHandler\n                context.getBean(<span class=\"hljs-name\">WEB_HANDLER_BEAN_NAME</span>, WebHandler.class), context)<span class=\"hljs-comment\">;</span>\n</code></pre>\n<p>不过这部分已经到了WebFlux初始化的层面了,就此打住, 接下来我们就知道了一个请求来到SOUL, 本质上是SOUL借助WebFlux 高性能 reacot模型的web框架, 扩展了一个WebHandler, 在Handler中对请求做pluginchain的处理,并最终代理访问真实地址, 实现网关功能.</p>\n","categories":[],"tags":[{"name":"SOUL","path":"api/tags/SOUL.json"}]}