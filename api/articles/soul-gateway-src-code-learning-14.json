{"title":"soul_gateway_src_code_learning_14","slug":"soul-gateway-src-code-learning-14","date":"2021-01-29T18:36:35.000Z","updated":"2021-01-29T19:01:49.241Z","comments":true,"excerpt":"","content":"<h3 id=\"SOUL-alibaba-dubbo-apache-dubbo-plugin-分析\"><a href=\"#SOUL-alibaba-dubbo-apache-dubbo-plugin-分析\" class=\"headerlink\" title=\"SOUL: alibaba-dubbo apache-dubbo plugin 分析\"></a>SOUL: alibaba-dubbo apache-dubbo plugin 分析</h3><p>dubbo插件主要讲http 请求 转化为dubbo请求, 实现泛化调用 soul-plugin/soul-plugin-apache-dubbo/src/main/java/org/dromara/soul/plugin/apache/dubbo/ApacheDubboPlugin.java</p>\n<pre><code class=\"java\">@Override\n    protected Mono&lt;Void&gt; doExecute(final ServerWebExchange exchange, final SoulPluginChain chain, final SelectorData selector, final RuleData rule) {\n        String body = exchange.getAttribute(Constants.DUBBO_PARAMS);\n        SoulContext soulContext = exchange.getAttribute(Constants.CONTEXT);\n        assert soulContext != null;\n      //  可以看到与divide插件, SpringCLoud插件的区别是这里用到了Metadata\n        MetaData metaData = exchange.getAttribute(Constants.META_DATA);\n        if (!checkMetaData(metaData)) {\n            assert metaData != null;\n            log.error(&quot; path is :{}, meta data have error.... {}&quot;, soulContext.getPath(), metaData.toString());\n            exchange.getResponse().setStatusCode(HttpStatus.INTERNAL_SERVER_ERROR);\n            Object error = SoulResultWrap.error(SoulResultEnum.META_DATA_ERROR.getCode(), SoulResultEnum.META_DATA_ERROR.getMsg(), null);\n            return WebFluxResultUtils.result(exchange, error);\n        }\n        if (StringUtils.isNoneBlank(metaData.getParameterTypes()) &amp;&amp; StringUtils.isBlank(body)) {\n            exchange.getResponse().setStatusCode(HttpStatus.INTERNAL_SERVER_ERROR);\n            Object error = SoulResultWrap.error(SoulResultEnum.DUBBO_HAVE_BODY_PARAM.getCode(), SoulResultEnum.DUBBO_HAVE_BODY_PARAM.getMsg(), null);\n            return WebFluxResultUtils.result(exchange, error);\n        }\n      //进行泛化调用\n        final Mono&lt;Object&gt; result = dubboProxyService.genericInvoker(body, metaData, exchange);\n        return result.then(chain.execute(exchange));\n    }\n</code></pre>\n<p>soul-plugin/soul-plugin-alibaba-dubbo/src/main/java/org/dromara/soul/plugin/alibaba/dubbo/AlibabaDubboPlugin.java 和ApacheDubboPlugin的逻辑基本一致, 只是下面部分有一点差别</p>\n<pre><code class=\"java\">......\n  //进行泛化调用\n        Object result = alibabaDubboProxyService.genericInvoker(body, metaData);\n//将结果放到 exchange中\n        if (Objects.nonNull(result)) {\n            exchange.getAttributes().put(Constants.DUBBO_RPC_RESULT, result);\n        } else {\n            exchange.getAttributes().put(Constants.DUBBO_RPC_RESULT, Constants.DUBBO_RPC_RESULT_EMPTY);\n        }\n        exchange.getAttributes().put(Constants.CLIENT_RESPONSE_RESULT_TYPE, ResultEnum.SUCCESS.getName());\n        return chain.execute(exchange);\n    }\n</code></pre>\n<pre><code class=\"java\">public Mono&lt;Object&gt; genericInvoker(final String body, final MetaData metaData, final ServerWebExchange exchange) throws SoulException {\n        // issue(https://github.com/dromara/soul/issues/471), add dubbo tag route\n        String dubboTagRouteFromHttpHeaders = exchange.getRequest().getHeaders().getFirst(Constants.DUBBO_TAG_ROUTE);\n        if (StringUtils.isNotBlank(dubboTagRouteFromHttpHeaders)) {\n            RpcContext.getContext().setAttachment(CommonConstants.TAG_KEY, dubboTagRouteFromHttpHeaders);\n        }\n        ReferenceConfig&lt;GenericService&gt; reference = ApplicationConfigCache.getInstance().get(metaData.getPath());\n        if (Objects.isNull(reference) || StringUtils.isEmpty(reference.getInterface())) {\n            ApplicationConfigCache.getInstance().invalidate(metaData.getPath());\n            reference = ApplicationConfigCache.getInstance().initRef(metaData);\n        }\n        GenericService genericService = reference.get();\n        Pair&lt;String[], Object[]&gt; pair;\n        if (ParamCheckUtils.dubboBodyIsEmpty(body)) {\n            pair = new ImmutablePair&lt;&gt;(new String[]{}, new Object[]{});\n        } else {\n            pair = dubboParamResolveService.buildParameter(body, metaData.getParameterTypes());\n        }\n        CompletableFuture&lt;Object&gt; future = genericService.$invokeAsync(metaData.getMethodName(), pair.getLeft(), pair.getRight());\n        return Mono.fromFuture(future.thenApply(ret -&gt; {\n            if (Objects.isNull(ret)) {\n                ret = Constants.DUBBO_RPC_RESULT_EMPTY;\n            }\n            exchange.getAttributes().put(Constants.DUBBO_RPC_RESULT, ret);\n            exchange.getAttributes().put(Constants.CLIENT_RESPONSE_RESULT_TYPE, ResultEnum.SUCCESS.getName());\n            return ret;\n        })).onErrorMap(exception -&gt; exception instanceof GenericException ? new SoulException(((GenericException) exception).getExceptionMessage()) : new SoulException(exception));\n    }\n}\n</code></pre>\n<p>soul-common/src/main/java/org/dromara/soul/common/dto/MetaData.java</p>\n<pre><code class=\"java\">@Data\n@ToString\n@Builder\n@NoArgsConstructor\n@AllArgsConstructor\npublic class MetaData implements Serializable {\n    private String id;\n    private String appName;\n    private String contextPath;\n    private String path;\n    private String rpcType;\n    private String serviceName;\n    private String methodName;\n    private String parameterTypes;\n    private String rpcExt;\n    private Boolean enabled;\n}\n</code></pre>\n<p>Medata中保存了dubbo接口的信息</p>\n<ul>\n<li>每一个dubbo接口方法，都会有一条metadata与之对应，可以在 soul-admin –&gt; Metadata中查看</li>\n</ul>\n<ul>\n<li>path: 即http路径</li>\n<li>rpc扩展参数，对应为dubbo接口的一些配置，调整的化，请在这里修改，支持json格式，以下字段：</li>\n</ul>\n<pre><code class=\"json\">{&quot;timeout&quot;:10000,&quot;group&quot;:&quot;&quot;,version&quot;:&quot;&quot;,&quot;loadbalance&quot;:&quot;&quot;,&quot;retries&quot;:1}\n</code></pre>\n<p>在soul-plugin/soul-plugin-apache-dubbo/src/main/java/org/dromara/soul/plugin/apache/dubbo/response/DubboResponsePlugin.java中返回result, alibaba-dubbo中的DubboResponsePlugin.java 同理</p>\n<pre><code class=\"java\">@Override\npublic Mono&lt;Void&gt; execute(final ServerWebExchange exchange, final SoulPluginChain chain) {\n    return chain.execute(exchange).then(Mono.defer(() -&gt; {\n        final Object result = exchange.getAttribute(Constants.DUBBO_RPC_RESULT);\n        if (Objects.isNull(result)) {\n            Object error = SoulResultWrap.error(SoulResultEnum.SERVICE_RESULT_ERROR.getCode(), SoulResultEnum.SERVICE_RESULT_ERROR.getMsg(), null);\n            return WebFluxResultUtils.result(exchange, error);\n        }\n        Object success = SoulResultWrap.success(SoulResultEnum.SUCCESS.getCode(), SoulResultEnum.SUCCESS.getMsg(), JsonUtils.removeClass(result));\n        return WebFluxResultUtils.result(exchange, success);\n    }));\n}\n</code></pre>\n","categories":[],"tags":[{"name":"SOUL","path":"api/tags/SOUL.json"}]}