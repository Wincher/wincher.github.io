{"title":"soul_gateway_src_code_learning_17","slug":"soul-gateway-src-code-learning-17","date":"2021-02-04T10:49:23.000Z","updated":"2021-02-04T23:02:03.112Z","comments":true,"excerpt":"","content":"<h3 id=\"SOUL-resilience4j-plugin\"><a href=\"#SOUL-resilience4j-plugin\" class=\"headerlink\" title=\"SOUL resilience4j plugin\"></a>SOUL resilience4j plugin</h3><p>首先启动项目 soul-admin, soul-bootstrap，以<code>soul-examples</code>中的<code>soul-example-http</code>为例，注册到soul网关上。检查soul-bootstrap的<code>pom</code>文件中是否引入相关依赖：</p>\n<pre><code class=\"xml\">        &lt;dependency&gt;\n            &lt;groupId&gt;org.dromara&lt;/groupId&gt;\n            &lt;artifactId&gt;soul-spring-boot-starter-plugin-resilience4j&lt;/artifactId&gt;\n            &lt;version&gt;${project.version}&lt;/version&gt;\n        &lt;/dependency&gt;\n</code></pre>\n<p>然后再SOUL admin中开启 resilient4j plugin</p>\n<p>同时配置selector以及相关rule, 制定相应的熔断策略, 相关 selector 配置</p>\n<p><a href=\"https://dromara.org/zh/projects/soul/resilience4j-plugin/\" target=\"_blank\" rel=\"external\">reference</a></p>\n<h1 id=\"探究Resilient4j插件\"><a href=\"#探究Resilient4j插件\" class=\"headerlink\" title=\"探究Resilient4j插件\"></a>探究Resilient4j插件</h1><p>Resilient4j plugin与其他插件一样继承了AbstractSoulPlugin, 核心逻辑如下</p>\n<pre><code class=\"java\">@Override\n    protected Mono&lt;Void&gt; doExecute(final ServerWebExchange exchange, final SoulPluginChain chain, final SelectorData selector, final RuleData rule) {\n        final SoulContext soulContext = exchange.getAttribute(Constants.CONTEXT);\n        assert soulContext != null;\n      //soul-admin同步来的json串生成Resilience4JHandle, 包含所有在soul-admin中的相关参数信息\n        Resilience4JHandle resilience4JHandle = GsonUtils.getGson().fromJson(rule.getHandle(), Resilience4JHandle.class);\n      //然后根据getCircuitEnable来确定是否创建熔断和限流的组合控件还是仅创建限流控件\n        if (resilience4JHandle.getCircuitEnable() == 1) {\n            return combined(exchange, chain, rule);\n        }\n        return rateLimiter(exchange, chain, rule);\n    }\n</code></pre>\n<p> CombinedExecutor和 RateLimiterExecutor<br>对于combined方法，核心代码如下</p>\n<pre><code class=\"java\">private Mono&lt;Void&gt; rateLimiter(final ServerWebExchange exchange, final SoulPluginChain chain, final RuleData rule) {\n        return ratelimiterExecutor.run(\n                chain.execute(exchange), fallback(ratelimiterExecutor, exchange, null), Resilience4JBuilder.build(rule))\n                .onErrorResume(throwable -&gt; ratelimiterExecutor.withoutFallback(exchange, throwable));\n    }\n\n    private Mono&lt;Void&gt; combined(final ServerWebExchange exchange, final SoulPluginChain chain, final RuleData rule) {\n        Resilience4JConf conf = Resilience4JBuilder.build(rule);\n        return combinedExecutor.run(\n                chain.execute(exchange).doOnSuccess(v -&gt; {\n                    HttpStatus status = exchange.getResponse().getStatusCode();\n                    if (status == null || !status.is2xxSuccessful()) {\n                        exchange.getResponse().setStatusCode(null);\n                        throw new CircuitBreakerStatusCodeException(status == null ? HttpStatus.INTERNAL_SERVER_ERROR : status);\n                    }\n                }), fallback(combinedExecutor, exchange, conf.getFallBackUri()), conf);\n    }\n</code></pre>\n<p> combinedExecutor 具体逻辑</p>\n<pre><code class=\"java\">public class CombinedExecutor implements Executor {\n\n    @Override\n    public &lt;T&gt; Mono&lt;T&gt; run(final Mono&lt;T&gt; run, final Function&lt;Throwable, Mono&lt;T&gt;&gt; fallback, final Resilience4JConf resilience4JConf) {\n      //调用 Resilience4J 创建熔断器和限流器\n        RateLimiter rateLimiter = Resilience4JRegistryFactory.rateLimiter(resilience4JConf.getId(), resilience4JConf.getRateLimiterConfig());\n        CircuitBreaker circuitBreaker = Resilience4JRegistryFactory.circuitBreaker(resilience4JConf.getId(), resilience4JConf.getCircuitBreakerConfig());\n        Mono&lt;T&gt; to = run.transformDeferred(CircuitBreakerOperator.of(circuitBreaker))\n                .transformDeferred(RateLimiterOperator.of(rateLimiter))\n                .timeout(resilience4JConf.getTimeLimiterConfig().getTimeoutDuration())\n                .doOnError(TimeoutException.class, t -&gt; circuitBreaker.onError(\n                        resilience4JConf.getTimeLimiterConfig().getTimeoutDuration().toMillis(),\n                        TimeUnit.MILLISECONDS,\n                        t));\n        if (fallback != null) {\n            to = to.onErrorResume(fallback);\n        }\n        return to;\n    }\n}\n</code></pre>\n<p>上面的 rateLimit和combined 方法都可以看到Resilience4JBuilder来生成Resilience4JConf, 这里通过SOUL的配置构建TimeLimiterConfig, CircuitBreakerConfig,RateLimiterConfig供调用Resilience4J使用</p>\n<pre><code class=\"java\">public static Resilience4JConf build(final RuleData ruleData) {\n        Resilience4JHandle handle = GsonUtils.getGson().fromJson(ruleData.getHandle(), Resilience4JHandle.class);\n        CircuitBreakerConfig circuitBreakerConfig = null;\n        if (handle.getCircuitEnable() == 1) {\n            circuitBreakerConfig = CircuitBreakerConfig.custom()\n                    .recordExceptions(Throwable.class, Exception.class)\n                    .failureRateThreshold(handle.getFailureRateThreshold())\n                    .automaticTransitionFromOpenToHalfOpenEnabled(handle.getAutomaticTransitionFromOpenToHalfOpenEnabled())\n                    .slidingWindow(handle.getSlidingWindowSize(), handle.getMinimumNumberOfCalls(),\n                            handle.getSlidingWindowType() == 0\n                                    ? CircuitBreakerConfig.SlidingWindowType.COUNT_BASED\n                                    : CircuitBreakerConfig.SlidingWindowType.TIME_BASED).waitIntervalFunctionInOpenState(IntervalFunction\n                            .of(Duration.ofSeconds(handle.getWaitIntervalFunctionInOpenState() / 1000)))\n                    .permittedNumberOfCallsInHalfOpenState(handle.getPermittedNumberOfCallsInHalfOpenState()).build();\n        }\n        TimeLimiterConfig timeLimiterConfig = TimeLimiterConfig.custom()\n                .timeoutDuration(Duration.ofSeconds(handle.getTimeoutDuration() / 1000)).build();\n        RateLimiterConfig rateLimiterConfig = RateLimiterConfig.custom()\n                .limitForPeriod(handle.getLimitForPeriod())\n                .timeoutDuration(Duration.ofSeconds(handle.getTimeoutDurationRate() / 1000))\n                .limitRefreshPeriod(Duration.ofNanos(handle.getLimitRefreshPeriod() * 1000000)).build();\n        return new Resilience4JConf(Resilience4JHandler.getResourceName(ruleData), handle.getFallbackUri(), rateLimiterConfig, timeLimiterConfig, circuitBreakerConfig);\n    }\n</code></pre>\n","categories":[],"tags":[{"name":"SOUL","path":"api/tags/SOUL.json"}]}