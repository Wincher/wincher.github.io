{"title":"soul_gateway_src_code_learning_13","slug":"soul-gateway-src-code-learning-13","date":"2021-01-28T14:23:58.000Z","updated":"2021-01-28T15:47:29.931Z","comments":true,"excerpt":"","content":"<h3 id=\"SOUL-SpringCloud-plugin-amp-WebClient-plugin\"><a href=\"#SOUL-SpringCloud-plugin-amp-WebClient-plugin\" class=\"headerlink\" title=\"SOUL: SpringCloud plugin &amp; WebClient plugin\"></a>SOUL: SpringCloud plugin &amp; WebClient plugin</h3><p>接上一章, 直接看 SpringCloud Plugin的处理逻辑</p>\n<p>加在SpringCloudplugin需要在soul-bootstrap/pom.xml加入</p>\n<pre><code class=\"xml\">&lt;!--soul springCloud plugin start--&gt;\n&lt;dependency&gt;\n       &lt;groupId&gt;org.dromara&lt;/groupId&gt;\n       &lt;artifactId&gt;soul-spring-boot-starter-plugin-springcloud&lt;/artifactId&gt;\n        &lt;version&gt;${last.version}&lt;/version&gt;\n  &lt;/dependency&gt;\n\n  &lt;dependency&gt;\n       &lt;groupId&gt;org.dromara&lt;/groupId&gt;\n       &lt;artifactId&gt;soul-spring-boot-starter-plugin-httpclient&lt;/artifactId&gt;\n       &lt;version&gt;${last.version}&lt;/version&gt;\n   &lt;/dependency&gt;\n   &lt;!--soul springCloud plugin end--&gt;\n\n   &lt;dependency&gt;\n        &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;\n        &lt;artifactId&gt;spring-cloud-commons&lt;/artifactId&gt;\n        &lt;version&gt;2.2.0.RELEASE&lt;/version&gt;\n   &lt;/dependency&gt;\n   &lt;dependency&gt;\n        &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;\n        &lt;artifactId&gt;spring-cloud-starter-netflix-ribbon&lt;/artifactId&gt;\n        &lt;version&gt;2.2.0.RELEASE&lt;/version&gt;\n   &lt;/dependency&gt;\n\n   &lt;!--使用 eureka 作为 springCloud的注册中心时 --&gt;\n   &lt;dependency&gt;\n       &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;\n       &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-client&lt;/artifactId&gt;\n       &lt;version&gt;2.2.0.RELEASE&lt;/version&gt;\n   &lt;/dependency&gt;  \n\n   &lt;!--使用 nacos 作为 springCloud的注册中心 --&gt;\n   &lt;dependency&gt;\n       &lt;groupId&gt;com.alibaba.cloud&lt;/groupId&gt;\n       &lt;artifactId&gt;spring-cloud-starter-alibaba-nacos-discovery&lt;/artifactId&gt;\n       &lt;version&gt;2.1.0.RELEASE&lt;/version&gt;\n   &lt;/dependency&gt;\n</code></pre>\n<p>同样在  soul-bootstrap/src/main/resources/application-local.yml 中</p>\n<pre><code class=\"yaml\"> # 使用 eureka\n  eureka:\n     client:\n       serviceUrl:\n         defaultZone: http://localhost:8761/eureka/\n     instance:\n       prefer-ip-address: true\n\n  # 使用 nacos   \n  spring:\n     cloud:\n       nacos:\n         discovery:\n            server-addr: 127.0.0.1:8848\n</code></pre>\n<p>看一下SpringCloud plugin的核心逻辑</p>\n<pre><code class=\"java\">@Override\n //同样是处理ServerWebExchange\n    protected Mono&lt;Void&gt; doExecute(final ServerWebExchange exchange, final SoulPluginChain chain, final SelectorData selector, final RuleData rule) {\n        if (Objects.isNull(rule)) {\n            return Mono.empty();\n        }\n        final SoulContext soulContext = exchange.getAttribute(Constants.CONTEXT);\n        assert soulContext != null;\n        //获取具体的SpringCLoudHandler\n        final SpringCloudRuleHandle ruleHandle = GsonUtils.getInstance().fromJson(rule.getHandle(), SpringCloudRuleHandle.class);\n        final SpringCloudSelectorHandle selectorHandle = GsonUtils.getInstance().fromJson(selector.getHandle(), SpringCloudSelectorHandle.class);\n        if (StringUtils.isBlank(selectorHandle.getServiceId()) || StringUtils.isBlank(ruleHandle.getPath())) {\n            Object error = SoulResultWrap.error(SoulResultEnum.CANNOT_CONFIG_SPRINGCLOUD_SERVICEID.getCode(), SoulResultEnum.CANNOT_CONFIG_SPRINGCLOUD_SERVICEID.getMsg(), null);\n            return WebFluxResultUtils.result(exchange, error);\n        }\n//通过LoadBalancerClient获取具体的ILoadBalancer实例\n        final ServiceInstance serviceInstance = loadBalancer.choose(selectorHandle.getServiceId());\n        if (Objects.isNull(serviceInstance)) {\n            Object error = SoulResultWrap.error(SoulResultEnum.SPRINGCLOUD_SERVICEID_IS_ERROR.getCode(), SoulResultEnum.SPRINGCLOUD_SERVICEID_IS_ERROR.getMsg(), null);\n            return WebFluxResultUtils.result(exchange, error);\n        }\n        final URI uri = loadBalancer.reconstructURI(serviceInstance, URI.create(soulContext.getRealUrl()));\n//拼装出真实目标地址url\n        String realURL = buildRealURL(uri.toASCIIString(), soulContext.getHttpMethod(), exchange.getRequest().getURI().getQuery());\n// set 真实地址到 exchange中\n        exchange.getAttributes().put(Constants.HTTP_URL, realURL);\n        //set time out.\n        exchange.getAttributes().put(Constants.HTTP_TIME_OUT, ruleHandle.getTimeout());\n        return chain.execute(exchange);\n    }\n</code></pre>\n<p>而后 WebClientPlugin会使用刚SpringCloud plugin 处理过后 并set 到SoulContext的真实地址去访问后台服务</p>\n<pre><code class=\"java\">public Mono&lt;Void&gt; execute(final ServerWebExchange exchange, final SoulPluginChain chain) {\n      final SoulContext soulContext = exchange.getAttribute(Constants.CONTEXT);\n      assert soulContext != null;\n      String urlPath = exchange.getAttribute(Constants.HTTP_URL);\n      if (StringUtils.isEmpty(urlPath)) {\n          Object error = SoulResultWrap.error(SoulResultEnum.CANNOT_FIND_URL.getCode(), SoulResultEnum.CANNOT_FIND_URL.getMsg(), null);\n          return WebFluxResultUtils.result(exchange, error);\n      }\n      long timeout = (long) Optional.ofNullable(exchange.getAttribute(Constants.HTTP_TIME_OUT)).orElse(3000L);\n      int retryTimes = (int) Optional.ofNullable(exchange.getAttribute(Constants.HTTP_RETRY)).orElse(0);\n      log.info(&quot;The request urlPath is {}, retryTimes is {}&quot;, urlPath, retryTimes);\n      HttpMethod method = HttpMethod.valueOf(exchange.getRequest().getMethodValue());\n      //WebClient是从Spring WebFlux 5.0版本开始提供基于响应式编程模型的非阻塞的HttpClient\n      //拼装请求\n      WebClient.RequestBodySpec requestBodySpec = webClient.method(method).uri(urlPath);\n      return handleRequestBody(requestBodySpec, exchange, timeout, retryTimes, chain);\n  }\nprivate Mono&lt;Void&gt; handleRequestBody(final WebClient.RequestBodySpec requestBodySpec,\n                                       final ServerWebExchange exchange,\n                                       final long timeout,\n                                       final int retryTimes,\n                                       final SoulPluginChain chain) {\n      return requestBodySpec.headers(httpHeaders -&gt; {\n          httpHeaders.addAll(exchange.getRequest().getHeaders());\n          httpHeaders.remove(HttpHeaders.HOST);\n      })\n              .contentType(buildMediaType(exchange))\n              .body(BodyInserters.fromDataBuffers(exchange.getRequest().getBody()))\n              .exchange()\n              .doOnError(e -&gt; log.error(e.getMessage()))\n              .timeout(Duration.ofMillis(timeout))\n              .retryWhen(Retry.onlyIf(x -&gt; x.exception() instanceof ConnectTimeoutException)\n                  .retryMax(retryTimes)\n                  .backoff(Backoff.exponential(Duration.ofMillis(200), Duration.ofSeconds(20), 2, true)))\n              .flatMap(e -&gt; doNext(e, exchange, chain));\n</code></pre>\n<p>至此, 请求被代理到了真实访问的服务.</p>\n","categories":[],"tags":[{"name":"SOUL","path":"api/tags/SOUL.json"}]}