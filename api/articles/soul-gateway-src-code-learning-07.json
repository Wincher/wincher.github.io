{"title":"soul_gateway_src_code_learning_07","slug":"soul-gateway-src-code-learning-07","date":"2021-01-21T17:03:03.000Z","updated":"2021-01-24T17:24:24.068Z","comments":true,"excerpt":"","content":"<h2 id=\"SOUL-Admin-amp-网关-Zookeeper-数据同步\"><a href=\"#SOUL-Admin-amp-网关-Zookeeper-数据同步\" class=\"headerlink\" title=\"SOUL Admin &amp; 网关 Zookeeper 数据同步\"></a>SOUL Admin &amp; 网关 Zookeeper 数据同步</h2><p><img src=\"/2021/01/22/soul-gateway-src-code-learning-07/00sync_starters.png\" alt=\"img\"></p>\n<p>目前SOUL提供了这几种数据同步方式, 上一节我们使用了WebSocket, 这一节使用Zookeerper来做数据同步, 代码实现结构与WebSocket如出一辙, 只不过具体的同步过程使用了Zookeeper自身的特性</p>\n<p>启动 zk,我用的docker <code>docker run -p 2181:2181 --restart unless-stopped --name zk -d zookeeper</code></p>\n<p>保证 soul-bootstrap pom.xml 引入</p>\n\n    <pre><code class=\"lang-xml\"><span class=\"xml\">        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">dependency</span>&gt;</span>\n            <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">groupId</span>&gt;</span>org.dromara<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">groupId</span>&gt;</span>\n            <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">artifactId</span>&gt;</span>soul-spring-boot-starter-sync-data-zookeeper<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">artifactId</span>&gt;</span>\n            <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">version</span>&gt;</span>$</span><span class=\"hljs-template-variable\">{project.version}</span><span class=\"xml\"><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">version</span>&gt;</span>\n        <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">dependency</span>&gt;</span>\n</span></code></pre>\n<p>soul-bootstrap/src/main/resources/application-local.yml 打开zk的配置,注释掉websocket(不注释掉的话就两种同步方式都开启,没有必要)</p>\n\n    <pre><code class=\"lang-yaml\"><span class=\"hljs-attribute\">soul</span>:\n    <span class=\"hljs-attribute\">sync</span>:\n#        <span class=\"hljs-attribute\">websocket </span>:\n#             <span class=\"hljs-attribute\">urls</span>: <span class=\"hljs-attribute\">ws</span>:<span class=\"hljs-comment\">//localhost:9095/websocket</span>\n\n        <span class=\"hljs-attribute\">zookeeper</span>:\n             <span class=\"hljs-attribute\">url</span>: <span class=\"hljs-attribute\">localhost</span>:<span class=\"hljs-number\">2181</span>\n             <span class=\"hljs-attribute\">sessionTimeout</span>: <span class=\"hljs-number\">5000</span>\n             <span class=\"hljs-attribute\">connectionTimeout</span>: <span class=\"hljs-number\">2000</span>\n</code></pre>\n<p>启动 bootstrap</p>\n\n    <pre><code class=\"lang-bash\">2021-01-22 01:22:42.073  <span class=\"hljs-builtin-name\">INFO</span> 48117 --- [           main] org.I0Itec.zkclient.ZkClient             : Waiting <span class=\"hljs-keyword\">for</span> keeper state SyncConnected\n2021-01-22 01:22:42.077  <span class=\"hljs-builtin-name\">INFO</span> 48117 --- [localhost:2181)] org.apache.zookeeper.ClientCnxn          : Opening socket<span class=\"hljs-built_in\"> connection </span><span class=\"hljs-keyword\">to</span><span class=\"hljs-built_in\"> server </span>localhost/127.0.0.1:2181. Will <span class=\"hljs-keyword\">not</span> attempt <span class=\"hljs-keyword\">to</span> authenticate using SASL (unknown error)\n2021-01-22 01:22:42.093  <span class=\"hljs-builtin-name\">INFO</span> 48117 --- [localhost:2181)] org.apache.zookeeper.ClientCnxn          : Socket<span class=\"hljs-built_in\"> connection </span>established, initiating session, client: /127.0.0.1:61106, server: localhost/127.0.0.1:2181\n2021-01-22 01:22:42.105  <span class=\"hljs-builtin-name\">INFO</span> 48117 --- [localhost:2181)] org.apache.zookeeper.ClientCnxn          : Session establishment complete on<span class=\"hljs-built_in\"> server </span>localhost/127.0.0.1:2181, sessionid = 0x100000074b10006, negotiated timeout = 5000\n2021-01-22 01:22:42.107  <span class=\"hljs-builtin-name\">INFO</span> 48117 --- [ain-EventThread] org.I0Itec.zkclient.ZkClient             : zookeeper state changed (SyncConnected)\n</code></pre>\n<p>查看zk, 我用是 zkCli, 可以看到在 / 路径下有了soul</p>\n<pre><code>[zk: localhost:2181(CONNECTED) 2] ls /soul\n[auth, metaData, plugin]\nls /soul/auth\n[]\n[zk: localhost:2181(CONNECTED) 4] ls /soul/metaData\n[]\n[zk: localhost:2181(CONNECTED) 5] ls /soul/plugin\n[]\n</code></pre><p>由于admin还没启动 目前auth, metaData, plugin都是空的</p>\n<p>同样修改soul-admin/src/main/resources/application.yml 打开zookeeper配置</p>\n\n    <pre><code class=\"lang-yaml\">  <span class=\"hljs-attribute\">sync</span>:\n#    <span class=\"hljs-attribute\">websocket</span>:\n#      <span class=\"hljs-attribute\">enabled</span>: true\n    <span class=\"hljs-attribute\">zookeeper</span>:\n        <span class=\"hljs-attribute\">url</span>: <span class=\"hljs-attribute\">localhost</span>:<span class=\"hljs-number\">2181</span>\n        <span class=\"hljs-attribute\">sessionTimeout</span>: <span class=\"hljs-number\">5000</span>\n        <span class=\"hljs-attribute\">connectionTimeout</span>: <span class=\"hljs-number\">2000</span>\n</code></pre>\n<p>启动 soul-admin/src/main/java/org/dromara/soul/admin/SoulAdminBootstrap.java</p>\n\n    <pre><code class=\"lang-bash\">2021-01-22 01:30:59.421  <span class=\"hljs-builtin-name\">INFO</span> 48224 --- [           main] org.I0Itec.zkclient.ZkClient             : Waiting <span class=\"hljs-keyword\">for</span> keeper state SyncConnected\n2021-01-22 01:30:59.426  <span class=\"hljs-builtin-name\">INFO</span> 48224 --- [localhost:2181)] org.apache.zookeeper.ClientCnxn          : Opening socket<span class=\"hljs-built_in\"> connection </span><span class=\"hljs-keyword\">to</span><span class=\"hljs-built_in\"> server </span>localhost/0:0:0:0:0:0:0:1:2181. Will <span class=\"hljs-keyword\">not</span> attempt <span class=\"hljs-keyword\">to</span> authenticate using SASL (unknown error)\n2021-01-22 01:30:59.443  <span class=\"hljs-builtin-name\">INFO</span> 48224 --- [localhost:2181)] org.apache.zookeeper.ClientCnxn          : Socket<span class=\"hljs-built_in\"> connection </span>established, initiating session, client: /0:0:0:0:0:0:0:1:61453, server: localhost/0:0:0:0:0:0:0:1:2181\n2021-01-22 01:30:59.453  <span class=\"hljs-builtin-name\">INFO</span> 48224 --- [localhost:2181)] org.apache.zookeeper.ClientCnxn          : Session establishment complete on<span class=\"hljs-built_in\"> server </span>localhost/0:0:0:0:0:0:0:1:2181, sessionid = 0x100000074b10007, negotiated timeout = 5000\n2021-01-22 01:30:59.454  <span class=\"hljs-builtin-name\">INFO</span> 48224 --- [ain-EventThread] org.I0Itec.zkclient.ZkClient             : zookeeper state changed (SyncConnected)\n</code></pre>\n<p>看log像是已经建立连接, 但并未找到同步数据的log, 查看zk, </p>\n<pre><code>[zk: localhost:2181(CONNECTED) 2] ls /soul\n[auth, metaData, plugin]\nls /soul/auth\n[]\n[zk: localhost:2181(CONNECTED) 4] ls /soul/metaData\n[]\n[zk: localhost:2181(CONNECTED) 5] ls /soul/plugin\n[]\n</code></pre><p>的确没有同步, 我们先分析一下zk同步的代码逻辑</p>\n<p>上一节分析 WebSocket数据同步的时候, WebsocketSyncDataService实现了, WebSocketsoul-sync-data-center/soul-sync-data-api/src/main/java/org/dromara/soul/sync/data/api/SyncDataService.java, 这个接口就是为多种数据同步方式定义的标准, 同样可以找到soul-sync-data-center/soul-sync-data-zookeeper/src/main/java/org/dromara/soul/sync/data/zookeeper/ZookeeperSyncDataService.java</p>\n\n    <pre><code class=\"lang-java\">                <span class=\"hljs-comment\">//构造方法中就会使用zookeeper的监听三组数据</span>\n                watcherData();\n        watchAppAuth();\n        watchMetaData();\n       <span class=\"hljs-comment\">//都是相同逻辑,只看一个就好 </span>\n        private <span class=\"hljs-keyword\">void</span> watcherData() {\n        <span class=\"hljs-keyword\">final</span> <span class=\"hljs-built_in\">String</span> pluginParent = ZkPathConstants.PLUGIN_PARENT;\n        <span class=\"hljs-built_in\">List</span>&lt;<span class=\"hljs-built_in\">String</span>&gt; pluginZKs = zkClientGetChildren(pluginParent);\n        <span class=\"hljs-comment\">//这里分别再去监听所有插件的内容</span>\n        <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-built_in\">String</span> pluginName : pluginZKs) {\n            watcherAll(pluginName);\n        }\n        <span class=\"hljs-comment\">//就是各种递归一层一层的找到所有可以被监听的节点都给与监听</span>\n        zkClient.subscribeChildChanges(pluginParent, (parentPath, currentChildren) -&gt; {\n            <span class=\"hljs-keyword\">if</span> (CollectionUtils.isNotEmpty(currentChildren)) {\n                <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-built_in\">String</span> pluginName : currentChildren) {\n                    watcherAll(pluginName);\n                }\n            }\n        });\n    }\n</code></pre>\n<p>大部分最后都会来到下面的代码, 可以看到这个代码被rule, selector, auth,metadata的监听最后调用 </p>\n<p><img src=\"/2021/01/22/soul-gateway-src-code-learning-07/01.png\" alt=\"img\"></p>\n\n    <pre><code class=\"lang-java\">//最后上面的, 可以看到根局不同的group key,如果还有监听,如果路径下面有还有paths, 调用队一行的<span class=\"hljs-keyword\">subscribe**datachagnes方法\n</span><span class=\"hljs-symbol\">private</span> void <span class=\"hljs-keyword\">subscribeChildChanges(final </span>ConfigGroupEnum groupKey, final <span class=\"hljs-keyword\">String </span>groupParentPath, final List&lt;<span class=\"hljs-keyword\">String&gt; </span>childrenList) {\n        <span class=\"hljs-keyword\">switch </span>(groupKey) {\n            case <span class=\"hljs-keyword\">SELECTOR:\n</span>                zkClient.<span class=\"hljs-keyword\">subscribeChildChanges(groupParentPath, </span>(parentPath, currentChildren) -&gt; {\n                    <span class=\"hljs-meta\">if</span> (CollectionUtils.isNotEmpty(currentChildren)) {\n                        List&lt;<span class=\"hljs-keyword\">String&gt; </span><span class=\"hljs-keyword\">addSubscribePath </span>= <span class=\"hljs-keyword\">addSubscribePath(childrenList, </span>currentChildren)<span class=\"hljs-comment\">;</span>\n                        <span class=\"hljs-keyword\">addSubscribePath.stream().map(addPath </span>-&gt; {\n                            <span class=\"hljs-keyword\">String </span>realPath = <span class=\"hljs-keyword\">buildRealPath(parentPath, </span><span class=\"hljs-keyword\">addPath);\n</span>                            cacheSelectorData(zkClient.readData(realPath))<span class=\"hljs-comment\">;</span>\n                            return realPath<span class=\"hljs-comment\">;</span>\n                        }).forEach(this::<span class=\"hljs-keyword\">subscribeSelectorDataChanges);\n</span>\n                    }\n                })<span class=\"hljs-comment\">;</span>\n                <span class=\"hljs-keyword\">break;\n</span>            case RULE:\n                zkClient.<span class=\"hljs-keyword\">subscribeChildChanges(groupParentPath, </span>(parentPath, currentChildren) -&gt; {\n                    <span class=\"hljs-meta\">if</span> (CollectionUtils.isNotEmpty(currentChildren)) {\n                        List&lt;<span class=\"hljs-keyword\">String&gt; </span><span class=\"hljs-keyword\">addSubscribePath </span>= <span class=\"hljs-keyword\">addSubscribePath(childrenList, </span>currentChildren)<span class=\"hljs-comment\">;</span>\n                        // <span class=\"hljs-meta\">Get</span> the newly <span class=\"hljs-keyword\">added </span>node <span class=\"hljs-meta\">data</span> <span class=\"hljs-keyword\">and </span><span class=\"hljs-keyword\">subscribe </span>to that node\n                        <span class=\"hljs-keyword\">addSubscribePath.stream().map(addPath </span>-&gt; {\n                            <span class=\"hljs-keyword\">String </span>realPath = <span class=\"hljs-keyword\">buildRealPath(parentPath, </span><span class=\"hljs-keyword\">addPath);\n</span>                            cacheRuleData(zkClient.readData(realPath))<span class=\"hljs-comment\">;</span>\n                            return realPath<span class=\"hljs-comment\">;</span>\n                        }).forEach(this::<span class=\"hljs-keyword\">subscribeRuleDataChanges);\n</span>                    }\n                })<span class=\"hljs-comment\">;</span>\n                <span class=\"hljs-keyword\">break;\n</span>            case APP_AUTH:\n                zkClient.<span class=\"hljs-keyword\">subscribeChildChanges(groupParentPath, </span>(parentPath, currentChildren) -&gt; {\n                    <span class=\"hljs-meta\">if</span> (CollectionUtils.isNotEmpty(currentChildren)) {\n                        final List&lt;<span class=\"hljs-keyword\">String&gt; </span><span class=\"hljs-keyword\">addSubscribePath </span>= <span class=\"hljs-keyword\">addSubscribePath(childrenList, </span>currentChildren)<span class=\"hljs-comment\">;</span>\n                        <span class=\"hljs-keyword\">addSubscribePath.stream().map(children </span>-&gt; {\n                            final <span class=\"hljs-keyword\">String </span>realPath = <span class=\"hljs-keyword\">buildRealPath(parentPath, </span>children)<span class=\"hljs-comment\">;</span>\n                            cacheAuthData(zkClient.readData(realPath))<span class=\"hljs-comment\">;</span>\n                            return realPath<span class=\"hljs-comment\">;</span>\n                        }).forEach(this::<span class=\"hljs-keyword\">subscribeAppAuthDataChanges);\n</span>                    }\n                })<span class=\"hljs-comment\">;</span>\n                <span class=\"hljs-keyword\">break;\n</span>            case META_DATA:\n                zkClient.<span class=\"hljs-keyword\">subscribeChildChanges(groupParentPath, </span>(parentPath, currentChildren) -&gt; {\n                    <span class=\"hljs-meta\">if</span> (CollectionUtils.isNotEmpty(currentChildren)) {\n                        final List&lt;<span class=\"hljs-keyword\">String&gt; </span><span class=\"hljs-keyword\">addSubscribePath </span>= <span class=\"hljs-keyword\">addSubscribePath(childrenList, </span>currentChildren)<span class=\"hljs-comment\">;</span>\n                        <span class=\"hljs-keyword\">addSubscribePath.stream().map(children </span>-&gt; {\n                            final <span class=\"hljs-keyword\">String </span>realPath = <span class=\"hljs-keyword\">buildRealPath(parentPath, </span>children)<span class=\"hljs-comment\">;</span>\n                            cacheMetaData(zkClient.readData(realPath))<span class=\"hljs-comment\">;</span>\n                            return realPath<span class=\"hljs-comment\">;</span>\n                        }).forEach(this::<span class=\"hljs-keyword\">subscribeMetaDataChanges);\n</span>                    }\n                })<span class=\"hljs-comment\">;</span>\n                <span class=\"hljs-keyword\">break;\n</span><span class=\"hljs-symbol\">            default:</span>\n                throw new IllegalStateException(<span class=\"hljs-string\">\"Unexpected groupKey: \"</span> + groupKey)<span class=\"hljs-comment\">;</span>\n        }\n    }\n</code></pre>\n<p>下面代码是核心逻辑, 当监听的节点发生变化, 同步数据 TODO: 至于 pluginDataSubscriber 等一系列的DataSubscriber后面分析</p>\n\n    <pre><code class=\"lang-java\"><span class=\"hljs-keyword\">private</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">subscribePluginDataChanges</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">final</span> String pluginPath, <span class=\"hljs-keyword\">final</span> String pluginName)</span> </span>{\n        zkClient.subscribeDataChanges(pluginPath, <span class=\"hljs-keyword\">new</span> IZkDataListener() {\n\n            <span class=\"hljs-meta\">@Override</span>\n\n            <span class=\"hljs-keyword\">public</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">handleDataChange</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">final</span> String dataPath, <span class=\"hljs-keyword\">final</span> Object data)</span> </span>{\n                Optional.ofNullable(data)\n                        .ifPresent(d -&gt; Optional.ofNullable(pluginDataSubscriber).ifPresent(e -&gt; e.onSubscribe((PluginData) d)));\n            }\n\n            <span class=\"hljs-meta\">@Override</span>\n            <span class=\"hljs-keyword\">public</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">handleDataDeleted</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">final</span> String dataPath)</span> </span>{\n                <span class=\"hljs-keyword\">final</span> PluginData data = <span class=\"hljs-keyword\">new</span> PluginData();\n                data.setName(pluginName);\n                Optional.ofNullable(pluginDataSubscriber).ifPresent(e -&gt; e.unSubscribe(data));\n            }\n        });\n    }\n</code></pre>\n<p>打开 <a href=\"http://localhost:9095/#/plug/divide\" target=\"_blank\" rel=\"external\">http://localhost:9095/#/plug/divide</a>, 点击</p>\n<p><img src=\"/2021/01/22/soul-gateway-src-code-learning-07/02sync_button.jpg\" alt=\"img\"></p>\n<p>在查看zk, 发现有值了</p>\n\n    <pre><code class=\"lang-bash\">[<span class=\"hljs-string\">zk:</span> <span class=\"hljs-string\">localhost:</span><span class=\"hljs-number\">2181</span>(CONNECTED) <span class=\"hljs-number\">19</span>] ls <span class=\"hljs-regexp\">/soul/</span>plugin\n[divide]\n</code></pre>\n<p>点一个插件就有一个插件的值, 这也未免太…我又找了一找, 果然 打开 <a href=\"http://localhost:9095/#/system/plugin\" target=\"_blank\" rel=\"external\">http://localhost:9095/#/system/plugin</a></p>\n<p>点击 <img src=\"/2021/01/22/soul-gateway-src-code-learning-07/03sync_all_button.jpg\" alt=\"img\"> </p>\n<p>再次查看全部同步了</p>\n<pre><code>[zk: localhost:2181(CONNECTED) 22] ls /soul/plugin\n[context_path, divide, dubbo, hystrix, monitor, rate_limiter, resilience4j, rewrite, sentinel, sign, sofa, springCloud, tars, waf]\n</code></pre><p>我们使用浏览器的network追踪了下</p>\n\n    <pre><code class=\"lang-bash\">Request <span class=\"hljs-string\">URL:</span> <span class=\"hljs-string\">http:</span><span class=\"hljs-comment\">//localhost:9095/plugin/syncPluginAll</span>\n</code></pre>\n<p>去看相关代码</p>\n\n    <pre><code class=\"lang-java\"><span class=\"hljs-meta\">@PostMapping</span>(<span class=\"hljs-string\">\"/syncPluginAll\"</span>)\n    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-function\">SoulAdminResult <span class=\"hljs-title\">syncPluginAll</span><span class=\"hljs-params\">()</span> </span>{\n        <span class=\"hljs-keyword\">boolean</span> success = syncDataService.syncAll(DataEventTypeEnum.REFRESH);\n        <span class=\"hljs-keyword\">if</span> (success) {\n            <span class=\"hljs-function\"><span class=\"hljs-keyword\">return</span> SoulAdminResult.<span class=\"hljs-title\">success</span><span class=\"hljs-params\">(SoulResultMessage.SYNC_SUCCESS)</span></span>;\n        } <span class=\"hljs-keyword\">else</span> {\n            <span class=\"hljs-function\"><span class=\"hljs-keyword\">return</span> SoulAdminResult.<span class=\"hljs-title\">error</span><span class=\"hljs-params\">(SoulResultMessage.SYNC_FAIL)</span></span>;\n        }\n    }\n</code></pre>\n<p>后面章节会以此为线索, 分析SyncDataService的工作机制</p>\n","categories":[],"tags":[]}