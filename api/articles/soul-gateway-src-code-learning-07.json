{"title":"soul_gateway_src_code_learning_07","slug":"soul-gateway-src-code-learning-07","date":"2021-01-21T17:03:03.000Z","updated":"2021-01-24T17:24:24.068Z","comments":true,"excerpt":"","content":"<h2 id=\"SOUL-Admin-amp-网关-Zookeeper-数据同步\"><a href=\"#SOUL-Admin-amp-网关-Zookeeper-数据同步\" class=\"headerlink\" title=\"SOUL Admin &amp; 网关 Zookeeper 数据同步\"></a>SOUL Admin &amp; 网关 Zookeeper 数据同步</h2><p><img src=\"/2021/01/22/soul-gateway-src-code-learning-07/00sync_starters.png\" alt=\"img\"></p>\n<p>目前SOUL提供了这几种数据同步方式, 上一节我们使用了WebSocket, 这一节使用Zookeerper来做数据同步, 代码实现结构与WebSocket如出一辙, 只不过具体的同步过程使用了Zookeeper自身的特性</p>\n<p>启动 zk,我用的docker <code>docker run -p 2181:2181 --restart unless-stopped --name zk -d zookeeper</code></p>\n<p>保证 soul-bootstrap pom.xml 引入</p>\n<pre><code class=\"xml\">        &lt;dependency&gt;\n            &lt;groupId&gt;org.dromara&lt;/groupId&gt;\n            &lt;artifactId&gt;soul-spring-boot-starter-sync-data-zookeeper&lt;/artifactId&gt;\n            &lt;version&gt;${project.version}&lt;/version&gt;\n        &lt;/dependency&gt;\n</code></pre>\n<p>soul-bootstrap/src/main/resources/application-local.yml 打开zk的配置,注释掉websocket(不注释掉的话就两种同步方式都开启,没有必要)</p>\n<pre><code class=\"yaml\">soul:\n    sync:\n#        websocket :\n#             urls: ws://localhost:9095/websocket\n\n        zookeeper:\n             url: localhost:2181\n             sessionTimeout: 5000\n             connectionTimeout: 2000\n</code></pre>\n<p>启动 bootstrap</p>\n<pre><code class=\"bash\">2021-01-22 01:22:42.073  INFO 48117 --- [           main] org.I0Itec.zkclient.ZkClient             : Waiting for keeper state SyncConnected\n2021-01-22 01:22:42.077  INFO 48117 --- [localhost:2181)] org.apache.zookeeper.ClientCnxn          : Opening socket connection to server localhost/127.0.0.1:2181. Will not attempt to authenticate using SASL (unknown error)\n2021-01-22 01:22:42.093  INFO 48117 --- [localhost:2181)] org.apache.zookeeper.ClientCnxn          : Socket connection established, initiating session, client: /127.0.0.1:61106, server: localhost/127.0.0.1:2181\n2021-01-22 01:22:42.105  INFO 48117 --- [localhost:2181)] org.apache.zookeeper.ClientCnxn          : Session establishment complete on server localhost/127.0.0.1:2181, sessionid = 0x100000074b10006, negotiated timeout = 5000\n2021-01-22 01:22:42.107  INFO 48117 --- [ain-EventThread] org.I0Itec.zkclient.ZkClient             : zookeeper state changed (SyncConnected)\n</code></pre>\n<p>查看zk, 我用是 zkCli, 可以看到在 / 路径下有了soul</p>\n<pre><code>[zk: localhost:2181(CONNECTED) 2] ls /soul\n[auth, metaData, plugin]\nls /soul/auth\n[]\n[zk: localhost:2181(CONNECTED) 4] ls /soul/metaData\n[]\n[zk: localhost:2181(CONNECTED) 5] ls /soul/plugin\n[]\n</code></pre><p>由于admin还没启动 目前auth, metaData, plugin都是空的</p>\n<p>同样修改soul-admin/src/main/resources/application.yml 打开zookeeper配置</p>\n<pre><code class=\"yaml\">  sync:\n#    websocket:\n#      enabled: true\n    zookeeper:\n        url: localhost:2181\n        sessionTimeout: 5000\n        connectionTimeout: 2000\n</code></pre>\n<p>启动 soul-admin/src/main/java/org/dromara/soul/admin/SoulAdminBootstrap.java</p>\n<pre><code class=\"bash\">2021-01-22 01:30:59.421  INFO 48224 --- [           main] org.I0Itec.zkclient.ZkClient             : Waiting for keeper state SyncConnected\n2021-01-22 01:30:59.426  INFO 48224 --- [localhost:2181)] org.apache.zookeeper.ClientCnxn          : Opening socket connection to server localhost/0:0:0:0:0:0:0:1:2181. Will not attempt to authenticate using SASL (unknown error)\n2021-01-22 01:30:59.443  INFO 48224 --- [localhost:2181)] org.apache.zookeeper.ClientCnxn          : Socket connection established, initiating session, client: /0:0:0:0:0:0:0:1:61453, server: localhost/0:0:0:0:0:0:0:1:2181\n2021-01-22 01:30:59.453  INFO 48224 --- [localhost:2181)] org.apache.zookeeper.ClientCnxn          : Session establishment complete on server localhost/0:0:0:0:0:0:0:1:2181, sessionid = 0x100000074b10007, negotiated timeout = 5000\n2021-01-22 01:30:59.454  INFO 48224 --- [ain-EventThread] org.I0Itec.zkclient.ZkClient             : zookeeper state changed (SyncConnected)\n</code></pre>\n<p>看log像是已经建立连接, 但并未找到同步数据的log, 查看zk, </p>\n<pre><code>[zk: localhost:2181(CONNECTED) 2] ls /soul\n[auth, metaData, plugin]\nls /soul/auth\n[]\n[zk: localhost:2181(CONNECTED) 4] ls /soul/metaData\n[]\n[zk: localhost:2181(CONNECTED) 5] ls /soul/plugin\n[]\n</code></pre><p>的确没有同步, 我们先分析一下zk同步的代码逻辑</p>\n<p>上一节分析 WebSocket数据同步的时候, WebsocketSyncDataService实现了, WebSocketsoul-sync-data-center/soul-sync-data-api/src/main/java/org/dromara/soul/sync/data/api/SyncDataService.java, 这个接口就是为多种数据同步方式定义的标准, 同样可以找到soul-sync-data-center/soul-sync-data-zookeeper/src/main/java/org/dromara/soul/sync/data/zookeeper/ZookeeperSyncDataService.java</p>\n<pre><code class=\"java\">                //构造方法中就会使用zookeeper的监听三组数据\n                watcherData();\n        watchAppAuth();\n        watchMetaData();\n       //都是相同逻辑,只看一个就好 \n        private void watcherData() {\n        final String pluginParent = ZkPathConstants.PLUGIN_PARENT;\n        List&lt;String&gt; pluginZKs = zkClientGetChildren(pluginParent);\n        //这里分别再去监听所有插件的内容\n        for (String pluginName : pluginZKs) {\n            watcherAll(pluginName);\n        }\n        //就是各种递归一层一层的找到所有可以被监听的节点都给与监听\n        zkClient.subscribeChildChanges(pluginParent, (parentPath, currentChildren) -&gt; {\n            if (CollectionUtils.isNotEmpty(currentChildren)) {\n                for (String pluginName : currentChildren) {\n                    watcherAll(pluginName);\n                }\n            }\n        });\n    }\n</code></pre>\n<p>大部分最后都会来到下面的代码, 可以看到这个代码被rule, selector, auth,metadata的监听最后调用 </p>\n<p><img src=\"/2021/01/22/soul-gateway-src-code-learning-07/01.png\" alt=\"img\"></p>\n<pre><code class=\"java\">//最后上面的, 可以看到根局不同的group key,如果还有监听,如果路径下面有还有paths, 调用队一行的subscribe**datachagnes方法\nprivate void subscribeChildChanges(final ConfigGroupEnum groupKey, final String groupParentPath, final List&lt;String&gt; childrenList) {\n        switch (groupKey) {\n            case SELECTOR:\n                zkClient.subscribeChildChanges(groupParentPath, (parentPath, currentChildren) -&gt; {\n                    if (CollectionUtils.isNotEmpty(currentChildren)) {\n                        List&lt;String&gt; addSubscribePath = addSubscribePath(childrenList, currentChildren);\n                        addSubscribePath.stream().map(addPath -&gt; {\n                            String realPath = buildRealPath(parentPath, addPath);\n                            cacheSelectorData(zkClient.readData(realPath));\n                            return realPath;\n                        }).forEach(this::subscribeSelectorDataChanges);\n\n                    }\n                });\n                break;\n            case RULE:\n                zkClient.subscribeChildChanges(groupParentPath, (parentPath, currentChildren) -&gt; {\n                    if (CollectionUtils.isNotEmpty(currentChildren)) {\n                        List&lt;String&gt; addSubscribePath = addSubscribePath(childrenList, currentChildren);\n                        // Get the newly added node data and subscribe to that node\n                        addSubscribePath.stream().map(addPath -&gt; {\n                            String realPath = buildRealPath(parentPath, addPath);\n                            cacheRuleData(zkClient.readData(realPath));\n                            return realPath;\n                        }).forEach(this::subscribeRuleDataChanges);\n                    }\n                });\n                break;\n            case APP_AUTH:\n                zkClient.subscribeChildChanges(groupParentPath, (parentPath, currentChildren) -&gt; {\n                    if (CollectionUtils.isNotEmpty(currentChildren)) {\n                        final List&lt;String&gt; addSubscribePath = addSubscribePath(childrenList, currentChildren);\n                        addSubscribePath.stream().map(children -&gt; {\n                            final String realPath = buildRealPath(parentPath, children);\n                            cacheAuthData(zkClient.readData(realPath));\n                            return realPath;\n                        }).forEach(this::subscribeAppAuthDataChanges);\n                    }\n                });\n                break;\n            case META_DATA:\n                zkClient.subscribeChildChanges(groupParentPath, (parentPath, currentChildren) -&gt; {\n                    if (CollectionUtils.isNotEmpty(currentChildren)) {\n                        final List&lt;String&gt; addSubscribePath = addSubscribePath(childrenList, currentChildren);\n                        addSubscribePath.stream().map(children -&gt; {\n                            final String realPath = buildRealPath(parentPath, children);\n                            cacheMetaData(zkClient.readData(realPath));\n                            return realPath;\n                        }).forEach(this::subscribeMetaDataChanges);\n                    }\n                });\n                break;\n            default:\n                throw new IllegalStateException(&quot;Unexpected groupKey: &quot; + groupKey);\n        }\n    }\n</code></pre>\n<p>下面代码是核心逻辑, 当监听的节点发生变化, 同步数据 TODO: 至于 pluginDataSubscriber 等一系列的DataSubscriber后面分析</p>\n<pre><code class=\"java\">private void subscribePluginDataChanges(final String pluginPath, final String pluginName) {\n        zkClient.subscribeDataChanges(pluginPath, new IZkDataListener() {\n\n            @Override\n\n            public void handleDataChange(final String dataPath, final Object data) {\n                Optional.ofNullable(data)\n                        .ifPresent(d -&gt; Optional.ofNullable(pluginDataSubscriber).ifPresent(e -&gt; e.onSubscribe((PluginData) d)));\n            }\n\n            @Override\n            public void handleDataDeleted(final String dataPath) {\n                final PluginData data = new PluginData();\n                data.setName(pluginName);\n                Optional.ofNullable(pluginDataSubscriber).ifPresent(e -&gt; e.unSubscribe(data));\n            }\n        });\n    }\n</code></pre>\n<p>打开 <a href=\"http://localhost:9095/#/plug/divide\" target=\"_blank\" rel=\"external\">http://localhost:9095/#/plug/divide</a>, 点击</p>\n<p><img src=\"/2021/01/22/soul-gateway-src-code-learning-07/02sync_button.jpg\" alt=\"img\"></p>\n<p>在查看zk, 发现有值了</p>\n<pre><code class=\"bash\">[zk: localhost:2181(CONNECTED) 19] ls /soul/plugin\n[divide]\n</code></pre>\n<p>点一个插件就有一个插件的值, 这也未免太…我又找了一找, 果然 打开 <a href=\"http://localhost:9095/#/system/plugin\" target=\"_blank\" rel=\"external\">http://localhost:9095/#/system/plugin</a></p>\n<p>点击 <img src=\"/2021/01/22/soul-gateway-src-code-learning-07/03sync_all_button.jpg\" alt=\"img\"> </p>\n<p>再次查看全部同步了</p>\n<pre><code>[zk: localhost:2181(CONNECTED) 22] ls /soul/plugin\n[context_path, divide, dubbo, hystrix, monitor, rate_limiter, resilience4j, rewrite, sentinel, sign, sofa, springCloud, tars, waf]\n</code></pre><p>我们使用浏览器的network追踪了下</p>\n<pre><code class=\"bash\">Request URL: http://localhost:9095/plugin/syncPluginAll\n</code></pre>\n<p>去看相关代码</p>\n<pre><code class=\"java\">@PostMapping(&quot;/syncPluginAll&quot;)\n    public SoulAdminResult syncPluginAll() {\n        boolean success = syncDataService.syncAll(DataEventTypeEnum.REFRESH);\n        if (success) {\n            return SoulAdminResult.success(SoulResultMessage.SYNC_SUCCESS);\n        } else {\n            return SoulAdminResult.error(SoulResultMessage.SYNC_FAIL);\n        }\n    }\n</code></pre>\n<p>后面章节会以此为线索, 分析SyncDataService的工作机制</p>\n","categories":[],"tags":[]}