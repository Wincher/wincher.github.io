{"title":"soul_gateway_src_code_learning_12","slug":"soul-gateway-src-code-learning-12","date":"2021-01-27T16:56:35.000Z","updated":"2021-01-27T18:02:56.285Z","comments":true,"excerpt":"","content":"<h3 id=\"SOUL-divide-plugin\"><a href=\"#SOUL-divide-plugin\" class=\"headerlink\" title=\"SOUL: divide plugin\"></a>SOUL: divide plugin</h3><p>通过上一节的分析, 我们知道了请求被plugin chain处理是通过 SoulWebHandler 中的静态类 DefaultSoulPluginChain 来处理的</p>\n<pre><code class=\"java\">@Override\n        public Mono&lt;Void&gt; execute(final ServerWebExchange exchange) {\n            return Mono.defer(() -&gt; {\n                if (this.index &lt; plugins.size()) {\n                    SoulPlugin plugin = plugins.get(this.index++);\n                    Boolean skip = plugin.skip(exchange);\n                    if (skip) {\n                        return this.execute(exchange);\n                    }\n                    return plugin.execute(exchange, this);\n                }\n                return Mono.empty();\n            });\n        }\n</code></pre>\n<p>soul-web/src/main/java/org/dromara/soul/web/configuration/SoulConfiguration.java 中注入plugin使用order做排序</p>\n<pre><code class=\"java\">final List&lt;SoulPlugin&gt; soulPlugins = pluginList.stream()\n                .sorted(Comparator.comparingInt(SoulPlugin::getOrder)).collect(Collectors.toList());\n</code></pre>\n<p>PluginEnum定义了插件的执行顺序,</p>\n<pre><code class=\"java\">public enum PluginEnum {\n    GLOBAL(1, 0, &quot;global&quot;),\n    SIGN(2, 0, &quot;sign&quot;),\n    WAF(10, 0, &quot;waf&quot;),\n    RATE_LIMITER(20, 0, &quot;rate_limiter&quot;),\n    CONTEXTPATH_MAPPING(25, 0, &quot;context_path&quot;),\n    REWRITE(30, 0, &quot;rewrite&quot;),\n    REDIRECT(40, 0, &quot;redirect&quot;),\n    HYSTRIX(45, 0, &quot;hystrix&quot;),\n    SENTINEL(45, 0, &quot;sentinel&quot;),\n    RESILIENCE4J(45, 0, &quot;resilience4j&quot;),\n    DIVIDE(50, 0, &quot;divide&quot;),\n    SPRING_CLOUD(50, 0, &quot;springCloud&quot;),\n    WEB_SOCKET(55, 0, &quot;webSocket&quot;),\n    DUBBO(60, 0, &quot;dubbo&quot;),\n    SOFA(60, 0, &quot;sofa&quot;),\n    TARS(60, 0, &quot;tars&quot;),\n    MONITOR(80, 0, &quot;monitor&quot;),\n    RESPONSE(100, 0, &quot;response&quot;);\n}\n</code></pre>\n<p>这一节来分析divide插件的处理逻辑</p>\n<pre><code class=\"java\">\nprotected Mono&lt;Void&gt; doExecute(final ServerWebExchange exchange, final SoulPluginChain chain, final SelectorData selector, final RuleData rule) {\n        final SoulContext soulContext = exchange.getAttribute(Constants.CONTEXT);\n        assert soulContext != null;\n        final DivideRuleHandle ruleHandle = GsonUtils.getInstance().fromJson(rule.getHandle(), DivideRuleHandle.class);\n  //从缓存中拿到后端代理\n        final List&lt;DivideUpstream&gt; upstreamList = UpstreamCacheManager.getInstance().findUpstreamListBySelectorId(selector.getId());\n        if (CollectionUtils.isEmpty(upstreamList)) {\n            log.error(&quot;divide upstream configuration error： {}&quot;, rule.toString());\n            Object error = SoulResultWrap.error(SoulResultEnum.CANNOT_FIND_URL.getCode(), SoulResultEnum.CANNOT_FIND_URL.getMsg(), null);\n            return WebFluxResultUtils.result(exchange, error);\n        }\n        final String ip = Objects.requireNonNull(exchange.getRequest().getRemoteAddress()).getAddress().getHostAddress();\n  //通过负载均衡算法拿到upstream\n        DivideUpstream divideUpstream = LoadBalanceUtils.selector(upstreamList, ruleHandle.getLoadBalance(), ip);\n        if (Objects.isNull(divideUpstream)) {\n            log.error(&quot;divide has no upstream&quot;);\n            Object error = SoulResultWrap.error(SoulResultEnum.CANNOT_FIND_URL.getCode(), SoulResultEnum.CANNOT_FIND_URL.getMsg(), null);\n            return WebFluxResultUtils.result(exchange, error);\n        }\n        // set the http url\n        String domain = buildDomain(divideUpstream);\n        String realURL = buildRealURL(domain, soulContext, exchange);\n  //对请求赋值真实访问的地址\n        exchange.getAttributes().put(Constants.HTTP_URL, realURL);\n        // set the http timeout\n        exchange.getAttributes().put(Constants.HTTP_TIME_OUT, ruleHandle.getTimeout());\n        exchange.getAttributes().put(Constants.HTTP_RETRY, ruleHandle.getRetry());\n        return chain.execute(exchange);\n    }\n</code></pre>\n<p>具体的负载均衡算法 实现了 LoadBalance 接口</p>\n<p><img src=\"/2021/01/28/soul-gateway-src-code-learning-12/00loadbalance_impls.png\" alt=\"img\"></p>\n<p>可以看到有三种实现, 分别是hash, random和roundrobin, 轮询算法, 通过SPI注入机制, soul自定义了加在spi的ExtensionLoader, 后面会单独分析</p>\n<p>另外网关遇到知道upstream的状态, 这里就涉及到了探活机制</p>\n<p>具体实现在 UpstreamCheckService</p>\n<pre><code class=\"java\">//此注解自动在Bean初始化后执行\n@PostConstruct\n    public void setup() {\n        PluginDO pluginDO = pluginMapper.selectByName(PluginEnum.DIVIDE.getName());\n      //初始化divide插件配置的所有upstream添加到UPSTREAM_MAP中\n        if (pluginDO != null) {\n            List&lt;SelectorDO&gt; selectorDOList = selectorMapper.findByPluginId(pluginDO.getId());\n            for (SelectorDO selectorDO : selectorDOList) {\n                List&lt;DivideUpstream&gt; divideUpstreams = GsonUtils.getInstance().fromList(selectorDO.getHandle(), DivideUpstream.class);\n                if (CollectionUtils.isNotEmpty(divideUpstreams)) {\n                    UPSTREAM_MAP.put(selectorDO.getName(), divideUpstreams);\n                }\n            }\n        }\n      //check属性使我们在application.yml中定义的soul.upstream.check值\n        if (check) {\n            new ScheduledThreadPoolExecutor(Runtime.getRuntime().availableProcessors(), SoulThreadFactory.create(&quot;scheduled-upstream-task&quot;, false))\n              //使用线程池对每一个upstream执行定时任务, 下面看下任务的具体逻辑\n                    .scheduleWithFixedDelay(this::scheduled, 10, scheduledTime, TimeUnit.SECONDS);\n        }\n    }\n</code></pre>\n<pre><code class=\"java\">private void scheduled() {\n        if (UPSTREAM_MAP.size() &gt; 0) {\n            UPSTREAM_MAP.forEach(this::check);\n        }\n}\n\nprivate void check(final String selectorName, final List&lt;DivideUpstream&gt; upstreamList) {\n        List&lt;DivideUpstream&gt; successList = Lists.newArrayListWithCapacity(upstreamList.size());\n        for (DivideUpstream divideUpstream : upstreamList) {\n          //方法中的核心逻辑使用Socket.connetct方法查看连接是否异常\n            final boolean pass = UpstreamCheckUtils.checkUrl(divideUpstream.getUpstreamUrl());\n            if (pass) {\n\n  //对结果进行处理,更新upstream状态\n                if (!divideUpstream.isStatus()) {\n                    divideUpstream.setTimestamp(System.currentTimeMillis());\n                    divideUpstream.setStatus(true);\n                    log.info(&quot;UpstreamCacheManager check success the url: {}, host: {} &quot;, divideUpstream.getUpstreamUrl(), divideUpstream.getUpstreamHost());\n                }\n                successList.add(divideUpstream);\n            } else {\n                divideUpstream.setStatus(false);\n                log.error(&quot;check the url={} is fail &quot;, divideUpstream.getUpstreamUrl());\n            }\n        }\n        if (successList.size() == upstreamList.size()) {\n            return;\n        }\n        if (successList.size() &gt; 0) {\n          //如果upstream并没有通过check, 更新新的成功连接的upstream list进入缓存\n            UPSTREAM_MAP.put(selectorName, successList);\n            updateSelectorHandler(selectorName, successList);\n        } else {\n            UPSTREAM_MAP.remove(selectorName);\n            updateSelectorHandler(selectorName, null);\n        }\n    }\n\n//通知DataChanged\n    private void updateSelectorHandler(final String selectorName, final List&lt;DivideUpstream&gt; upstreams) {\n        SelectorDO selectorDO = selectorMapper.selectByName(selectorName);\n        if (Objects.nonNull(selectorDO)) {\n            List&lt;ConditionData&gt; conditionDataList = ConditionTransfer.INSTANCE.mapToSelectorDOS(\n                    selectorConditionMapper.selectByQuery(new SelectorConditionQuery(selectorDO.getId())));\n            PluginDO pluginDO = pluginMapper.selectById(selectorDO.getPluginId());\n            String handler = CollectionUtils.isEmpty(upstreams) ? &quot;&quot; : GsonUtils.getInstance().toJson(upstreams);\n            selectorDO.setHandle(handler);\n            selectorMapper.updateSelective(selectorDO);\n            if (Objects.nonNull(pluginDO)) {\n                SelectorData selectorData = SelectorDO.transFrom(selectorDO, pluginDO.getName(), conditionDataList);\n                selectorData.setHandle(handler);\n                // publish change event.\n                eventPublisher.publishEvent(new DataChangedEvent(ConfigGroupEnum.SELECTOR, DataEventTypeEnum.UPDATE,\n                                                                 Collections.singletonList(selectorData)));\n            }\n        }\n    }\n</code></pre>\n<p>TODO;更细致的分析</p>\n","categories":[],"tags":[{"name":"SOUL","path":"api/tags/SOUL.json"}]}