{"title":"soul_gateway_src_code_learning_06","slug":"soul-gateway-src-code-learning-06","date":"2021-01-20T15:57:43.000Z","updated":"2021-01-20T16:59:42.480Z","comments":true,"excerpt":"","content":"<h2 id=\"SOUL-Admin-amp-网关-Websocket-数据同步\"><a href=\"#SOUL-Admin-amp-网关-Websocket-数据同步\" class=\"headerlink\" title=\"SOUL Admin &amp; 网关 Websocket 数据同步\"></a>SOUL Admin &amp; 网关 Websocket 数据同步</h2><p>启动后 admin 和 bootstrap 后, admin log中可以看到</p>\n<pre><code class=\"java\">2021-01-21 00:09:46.004  INFO 11893 --- [0.0-9095-exec-8] o.d.s.a.l.websocket.WebsocketCollector   : websocket on open successful....\n</code></pre>\n<p>根据log找到 soul-admin/src/main/java/org/dromara/soul/admin/listener/websocket/WebsocketCollector.java ,</p>\n<pre><code class=\"java\">@ServerEndpoint(&quot;/websocket&quot;)\npublic class WebsocketCollector {\n......\n</code></pre>\n<p>可见admin是一个server端, 那么调用方就在bootstrap中了, bootstrap中有这样一条log</p>\n<pre><code class=\"java\">2021-01-20 23:16:02.285  INFO 21427 --- [           main] b.s.s.d.w.WebsocketSyncDataConfiguration : you use websocket sync soul data.......\n</code></pre>\n<p>找到 soul-spring-boot-starter/soul-spring-boot-starter-sync-data-center/soul-spring-boot-starter-sync-data-websocket/src/main/java/org/dromara/soul/spring/boot/starter/sync/data/websocket/WebsocketSyncDataConfiguration.java</p>\n<pre><code class=\"java\">@Bean\n    public SyncDataService websocketSyncDataService(final ObjectProvider&lt;WebsocketConfig&gt; websocketConfig, final ObjectProvider&lt;PluginDataSubscriber&gt; pluginSubscriber,\n                                           final ObjectProvider&lt;List&lt;MetaDataSubscriber&gt;&gt; metaSubscribers, final ObjectProvider&lt;List&lt;AuthDataSubscriber&gt;&gt; authSubscribers) {\n        log.info(&quot;you use websocket sync soul data.......&quot;);\n        return new WebsocketSyncDataService(websocketConfig.getIfAvailable(WebsocketConfig::new), pluginSubscriber.getIfAvailable(),\n                metaSubscribers.getIfAvailable(Collections::emptyList), authSubscribers.getIfAvailable(Collections::emptyList));\n    }\n</code></pre>\n<p>  其中 websocketCondfig 来自</p>\n<pre><code class=\"java\">@Bean\n    @ConfigurationProperties(prefix = &quot;soul.sync.websocket&quot;)\n    public WebsocketConfig websocketConfig() {\n        return new WebsocketConfig();\n    }\n</code></pre>\n<p>properties 来自如下配置:</p>\n<p>soul-bootstrap/src/main/resources/application-local.yml </p>\n<pre><code class=\"yaml\">soul :\n    sync:\n        websocket :\n             urls: ws://localhost:9095/websocket\n</code></pre>\n<p>WebsocketSyncDataService 构造方法</p>\n<pre><code class=\"java\">    public WebsocketSyncDataService(final WebsocketConfig websocketConfig,\n                                    final PluginDataSubscriber pluginDataSubscriber,\n                                    final List&lt;MetaDataSubscriber&gt; metaDataSubscribers,\n                                    final List&lt;AuthDataSubscriber&gt; authDataSubscribers) {\n      //可配置多个admin地址\n        String[] urls = StringUtils.split(websocketConfig.getUrls(), &quot;,&quot;);\n      //构建线程池\n        executor = new ScheduledThreadPoolExecutor(urls.length, SoulThreadFactory.create(&quot;websocket-connect&quot;, true));\n        for (String url : urls) {\n            try {\n              //这个clients 是定义的 private final List&lt;WebSocketClient&gt; clients = new ArrayList&lt;&gt;();\n              //下面会分析SoulWebSocketClient\n                clients.add(new SoulWebsocketClient(new URI(url), Objects.requireNonNull(pluginDataSubscriber), metaDataSubscribers, authDataSubscribers));\n            } catch (URISyntaxException e) {\n                log.error(&quot;websocket url({}) is error&quot;, url, e);\n            }\n        }\n        try {\n          //初始化对所有的WebSocketClient建立连接\n            for (WebSocketClient client : clients) {\n                boolean success = client.connectBlocking(3000, TimeUnit.MILLISECONDS);\n                if (success) {\n                    log.info(&quot;websocket connection is successful.....&quot;);\n                } else {\n                    log.error(&quot;websocket connection is error.....&quot;);\n                }\n              //每30秒去重连断开连接的WebSocket连接\n                executor.scheduleAtFixedRate(() -&gt; {\n                    try {\n                        if (client.isClosed()) {\n                            boolean reconnectSuccess = client.reconnectBlocking();\n                            if (reconnectSuccess) {\n                                log.info(&quot;websocket reconnect is successful.....&quot;);\n                            } else {\n                                log.error(&quot;websocket reconnection is error.....&quot;);\n                            }\n                        }\n                    } catch (InterruptedException e) {\n                        log.error(&quot;websocket connect is error :{}&quot;, e.getMessage());\n                    }\n                }, 10, 30, TimeUnit.SECONDS);\n            }\n            /* client.setProxy(new Proxy(Proxy.Type.HTTP, new InetSocketAddress(&quot;proxyaddress&quot;, 80)));*/\n        } catch (InterruptedException e) {\n            log.info(&quot;websocket connection...exception....&quot;, e);\n        }\n\n    }\n</code></pre>\n<p>这样和Admin之间的通信就建立了, 那接下来就是数据的同步了, 上面代码中 我们使用了自己封装的 SoulWebSocketClient</p>\n<pre><code class=\"java\">//这个标记了此client是否已经发送了握手请求到admin, 详情看下面onOpen方法\nprivate volatile boolean alreadySync = Boolean.FALSE;\n\npublic SoulWebsocketClient(final URI serverUri, final PluginDataSubscriber pluginDataSubscriber,\n                           final List&lt;MetaDataSubscriber&gt; metaDataSubscribers, final List&lt;AuthDataSubscriber&gt; authDataSubscribers) {\n    super(serverUri);\n  //初始化的时候我们传入了websocketDataHandler, 顾名思义是要处理通信的数据的\n    this.websocketDataHandler = new WebsocketDataHandler(pluginDataSubscriber, metaDataSubscribers, authDataSubscribers);\n}\n\n@Override\n    public void onOpen(final ServerHandshake serverHandshake) {\n      //client第一次onOpen, 建立连接后会发送DataEventTypeEnum.MYSELF.name()消息到admin, 这里有个印象, 后面会讲道它的用途\n        if (!alreadySync) {\n            send(DataEventTypeEnum.MYSELF.name());\n            alreadySync = true;\n        }\n    }\n\n@Override\npublic void onMessage(final String result) {\n  handleResult(result);\n}\n\n\n@SuppressWarnings(&quot;ALL&quot;)\nprivate void handleResult(final String result) {\n  WebsocketData websocketData = GsonUtils.getInstance().fromJson(result, WebsocketData.class);\n  ConfigGroupEnum groupEnum = ConfigGroupEnum.acquireByName(websocketData.getGroupType());\n  String eventType = websocketData.getEventType();\n  String json = GsonUtils.getInstance().toJson(websocketData.getData());\n  //果不其然, onMessage使用了 websocketDataHandler 来处理数据\n  websocketDataHandler.executor(groupEnum, json, eventType);\n}\n</code></pre>\n<pre><code class=\"java\">public WebsocketDataHandler(final PluginDataSubscriber pluginDataSubscriber,\n                            final List&lt;MetaDataSubscriber&gt; metaDataSubscribers,\n                            final List&lt;AuthDataSubscriber&gt; authDataSubscribers) {\n    ENUM_MAP.put(ConfigGroupEnum.PLUGIN, new PluginDataHandler(pluginDataSubscriber));\n    ENUM_MAP.put(ConfigGroupEnum.SELECTOR, new SelectorDataHandler(pluginDataSubscriber));\n    ENUM_MAP.put(ConfigGroupEnum.RULE, new RuleDataHandler(pluginDataSubscriber));\n    ENUM_MAP.put(ConfigGroupEnum.APP_AUTH, new AuthDataHandler(authDataSubscribers));\n    ENUM_MAP.put(ConfigGroupEnum.META_DATA, new MetaDataHandler(metaDataSubscribers));\n}\n\npublic void executor(final ConfigGroupEnum type, final String json, final String eventType) {\n  //WebsocketDataHandler初始化的时候定义了几种Config类型为key, 讲handler作为value存入map中\n  //使用对应的handler处理json\n        ENUM_MAP.get(type).handle(json, eventType);\n}\n</code></pre>\n<p>上面的DataHandler都继承自 soul-sync-data-center/soul-sync-data-websocket/src/main/java/org/dromara/soul/plugin/sync/data/websocket/handler/AbstractDataHandler.java,  会根据不同的eventType来对数据进行不同的操作</p>\n<pre><code class=\"java\">@Override\n    public void handle(final String json, final String eventType) {\n        List&lt;T&gt; dataList = convert(json);\n        if (CollectionUtils.isNotEmpty(dataList)) {\n            DataEventTypeEnum eventTypeEnum = DataEventTypeEnum.acquireByName(eventType);\n            switch (eventTypeEnum) {\n                case REFRESH:\n                case MYSELF:\n                    doRefresh(dataList);\n                    break;\n                case UPDATE:\n                case CREATE:\n                    doUpdate(dataList);\n                    break;\n                case DELETE:\n                    doDelete(dataList);\n                    break;\n                default:\n                    break;\n            }\n        }\n</code></pre>\n<p>然后回到最开始的 soul-admin/src/main/java/org/dromara/soul/admin/listener/websocket/WebsocketCollector.java </p>\n<pre><code class=\"java\">@OnMessage\n    public void onMessage(final String message, final Session session) {\n      //admin如果收到DataEventTypeEnum.MYSELF.name(), 还记得上面bootstrap中每个client只有第一次onOpen才会发送的消息吗\n        if (message.equals(DataEventTypeEnum.MYSELF.name())) {\n            try {\n                ThreadLocalUtil.put(SESSION_KEY, session);\n                SpringBeanUtils.getInstance().getBean(SyncDataService.class).syncAll(DataEventTypeEnum.MYSELF);\n            } finally {\n                ThreadLocalUtil.clear();\n            }\n        }\n    }\n</code></pre>\n<p>TODO:  这块MYSELF的含义具体分析下</p>\n","categories":[],"tags":[{"name":"SOUL","path":"api/tags/SOUL.json"}]}