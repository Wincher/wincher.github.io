{"title":"soul_gateway_src_code_learning_18","slug":"soul-gateway-src-code-learning-18","date":"2021-02-05T14:12:00.000Z","updated":"2021-02-05T14:54:59.595Z","comments":true,"excerpt":"","content":"<h3 id=\"Sentinel-Plugin\"><a href=\"#Sentinel-Plugin\" class=\"headerlink\" title=\"Sentinel Plugin\"></a>Sentinel Plugin</h3><p>[reference]<a href=\"https://dromara.org/zh/projects/soul/sentinel-plugin/\" target=\"_blank\" rel=\"external\">https://dromara.org/zh/projects/soul/sentinel-plugin/</a></p>\n<p>在bootstrap pom.xml 中添加 sentinel的支持</p>\n<pre><code class=\"XML\">        &lt;!-- soul sentinel plugin start--&gt;\n        &lt;dependency&gt;\n            &lt;groupId&gt;org.dromara&lt;/groupId&gt;\n            &lt;artifactId&gt;soul-spring-boot-starter-plugin-sentinel&lt;/artifactId&gt;\n            &lt;version&gt;${project.version}&lt;/version&gt;\n        &lt;/dependency&gt;\n        &lt;!-- soul sentinel plugin end--&gt;\n</code></pre>\n<p>然后再SOUL admin中开启 Sentinel plugin</p>\n<p>同时配置selector以及相关rule, 制定相应的熔断策略, 相关 selector 配置</p>\n<p>Sentinel plugin与其他插件一样继承了AbstractSoulPlugin, 核心逻辑如下</p>\n<pre><code class=\"java\">\n    protected Mono&lt;Void&gt; doExecute(final ServerWebExchange exchange, final SoulPluginChain chain, final SelectorData selector, final RuleData rule) {\n        final SoulContext soulContext = exchange.getAttribute(Constants.CONTEXT);\n        assert soulContext != null;\n        String resourceName = SentinelRuleHandle.getResourceName(rule);\n        SentinelHandle sentinelHandle = GsonUtils.getInstance().fromJson(rule.getHandle(), SentinelHandle.class);\n        return chain.execute(exchange).transform(new SentinelReactorTransformer&lt;&gt;(resourceName)).doOnSuccess(v -&gt; {\n            HttpStatus status = exchange.getResponse().getStatusCode();\n            if (status == null || !status.is2xxSuccessful()) {\n                exchange.getResponse().setStatusCode(null);\n                throw new SentinelFallbackException(status == null ? HttpStatus.INTERNAL_SERVER_ERROR : status);\n            }\n        }).onErrorResume(throwable -&gt; sentinelFallbackHandler.fallback(exchange, UriUtils.createUri(sentinelHandle.getFallbackUri()), throwable));\n    }\n</code></pre>\n<p>这里使用 transform 加入一个函数作用于所有订阅者</p>\n<p>SentinelReactorTransformer 是Sentinel提供的主要的熔断实现类,会在所有插件执行完毕后执行,实现完美的解耦</p>\n<p>SentinelReactorTransformer 继承了 publisher, 使用发布订阅的工作模式, 对应订阅类 SentinelReactorSubscriber, 在执行插件链的最后执行 SentinelReactorSubscriber 中的 hookOnSubscribe(),之后完全交给 Sentinal 做处理</p>\n<pre><code class=\"java\">   @Override\n    protected void hookOnSubscribe(Subscription subscription) {\n        doWithContextOrCurrent(() -&gt; currentContext().getOrEmpty(SentinelReactorConstants.SENTINEL_CONTEXT_KEY),\n            this::entryWhenSubscribed);\n    }\n</code></pre>\n<p>这个里面用到大量 webflux 编程，后续搞定出Reactor</p>\n","categories":[],"tags":[{"name":"SOUL","path":"api/tags/SOUL.json"}]}